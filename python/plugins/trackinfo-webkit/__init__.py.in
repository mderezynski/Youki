
# -*- coding: utf-8 -*-
# -*- mode:python ; tab-width:4 -*- ex:set tabstop=4 shiftwidth=4 expandtab: -*-
#
# MPX Trackinfo
# (C) 2008 M. Derezynski
#

import copy
import gobject
import gst
import gtk
import gtk.glade
import httplib
import mpx
import musicbrainz2
import musicbrainz2.webservice as ws
import os
import pango
import pygst
import pygtk
import re
import string
import threading
import time
import urllib
import urllib2
import webkit
from Ft.Xml.XPath.Context import Context
from Ft.Xml.XPath import Evaluate
from Ft.Xml.Domlette import NonvalidatingReader
from Ft.Xml import EMPTY_NAMESPACE

def realId(entityId):

    if (entityId[:7] == "http://"):
        return string.split(entityId,"/")[-1]
    else:
        return entityId

def getLastFMArtistInfo(artistname):

        request = mpx.LastFMArtistMetadataRequestString(artistname)
        headers = {"Content-Type"   :"text/xml",
                   "Accept"         :"text/utf-8",
                   "User-Agent"     :"MPX-1.0"}
        conn = httplib.HTTPConnection("ws.audioscrobbler.com:80")
        conn.request("POST", "/1.0/rw/xmlrpc.php", request, headers)
        response = conn.getresponse()
        data = response.read()
        conn.close()

        artist = ""

        try:
                reader = NonvalidatingReader.parseString(data)
                context = Context(reader)
                wikitext = Evaluate("//member[name = 'wikiText']/value/string", context=context)
    
                artist = wikitext[0].firstChild.data
                re1 = re.compile("(\\[[^\\]]+\\])")
                re2 = re.compile("(\\[\\/[^\\]]+\\])")
                artist = re1.sub("",artist)
                artist = re2.sub("",artist)
        except:
                artist = "No artist data on Last.fm"

        return artist

def displayRelations(rels): 

    html = ""
    translit = {"Discogs":"Discogs Link", "Wikipedia":"Wikipedia Link", "Myspace":"Myspace Website", "OfficialHomepage":"Band Homepage"}
    ar = {}

    for rel in rels:

        mbns, hash, reltype = rel.getType().partition("#")
        try:
            ar[reltype].append(rel)
        except:
            ar[reltype] = []
            ar[reltype].append(rel)

    for a in ar:

        if a in translit: 

            rls = ar[a]
            for rel in rls:
                if len(rls) > 1:
                    html += "<a href='%s'>%s</a>(%s)" % (rel.getTargetId(), translit[a], str(rls.index(rel)+1))
                else:
                    html += "<a href='%s'>%s</a>" % (rel.getTargetId(), translit[a])

                html += "  "

    return html

class ArtistInfoQuery (threading.Thread):

    def __init__ (self, artistid, artistname, query, wsinc, wsinc_release): 

        self.query = query 
        self.wsinc = wsinc 
        self.wsinc_release = wsinc_release 

        threading.Thread.__init__(self)
        self.finished = threading.Event()
        self.artistid = artistid
        self.artistname = artistname.replace("+", " ")
        self.html = ""

    def is_done(self):

        return self.finished.isSet()

    def get_html(self):

        return self.html

    def stop (self):

        self.finished.set()
        self.join()

    def run (self):

        artist = getLastFMArtistInfo(self.artistname)

        self.html += "<div style='height: 2em; margin-bottom: 1em; padding-left: 0.5em; background-color: #909090; color: black; font-size: 1.5em;font-weight: bold'><p style='line-height: 2em'>About %s</p></div>" % self.artistname 
        self.html += artist

        self.html += "<div style='height: 2em; margin-bottom: 1em; padding-left: 0.5em; background-color: #909090; color: black; font-size: 1.5em;font-weight: bold'><p style='line-height: 2em'>Contributor Links</p></div>"

        try:
                entity = self.query.getArtistById(self.artistid, self.wsinc)   
                self.html += "<b>%s</b>(%s): " % (entity.getName(), self.artistid)
                self.html += displayRelations(entity.getRelations())
                self.html += "<br/>"
        except:
                print "TRACKINFO-WEBKIT: No Last.fm artist info" 

        self.finished.set()

class TrackInfoQuery (threading.Thread):

    def __init__ (self, track, query, wsinc, wsinc_release): 

        self.query = query
        self.wsinc = wsinc 
        self.wsinc_release = wsinc_release 

        threading.Thread.__init__(self)
        self.finished = threading.Event()
        self.track = track
        self.html = ""

    def is_done(self):

        return self.finished

    def get_html(self):

        return self.html

    def stop (self):

        self.finished.set()
        self.join()

    def run (self):

        try:
                artist = getLastFMArtistInfo(self.track[mpx.AttributeId.ARTIST].get())

                self.html += "<div style='height: 2em; margin-bottom: 1em; padding-left: 0.5em; background-color: #909090; color: black; font-size: 1.5em;font-weight: bold'><p style='line-height: 2em'>About %s</p></div>" % self.track[mpx.AttributeId.ARTIST].get()
                self.html += artist
        except:
                pass 

        try:
                req  = urllib2.urlopen("http://lyricwiki.org/api.php?fmt=text&artist=%s&song=%s"
                        % (urllib.quote(self.track[mpx.AttributeId.ARTIST].get()), urllib.quote(self.track[mpx.AttributeId.TITLE].get())))
                lyrics = req.read()
                if lyrics != "Not found":
                    self.html += "<div style='height: 2em; margin-bottom: 1em; padding-left: 0.5em; background-color: #909090; color: black; font-size: 1.5em;font-weight: bold'><p style='line-height: 2em'>Lyrics</p></div>"
                    self.html += lyrics.replace("\n","<br/>")
        except:
                print "TRACKINFO-WEBKIT: Error fetching lyrics" 

        if self.track[mpx.AttributeId.MB_TRACK_ID]:

            Relations = {}
            self.Entities = []

            try:
                    TrackId = self.track.get(mpx.AttributeId.MB_TRACK_ID).get()
                    MbTrack = self.query.getTrackById(TrackId, self.wsinc) 
            except:
                    print "TRACKINFO-WEBKIT: MusicBrainz WS error"
                    self.finished.set()
                    return;

            MbRelations = MbTrack.getRelations()

            for Relation in MbRelations:

                if Relation.getDirection() != "backward":
    
                    x,y,relation_type = Relation.getType().partition("#")

                    try:
                        Relations[relation_type].append(Relation)
                    except:
                        Relations[relation_type] = [Relation]


            CallTable = {"Cover"             :   [self.append_ar_coverversion],
                         "Instrument"        :   [self.append_ar_instrument],
                         "SamplesMaterial"   :   [self.append_ar_samplesmaterial],
                         "Composer"          :   [self.append_ar_singleperson, "was composed by"],
                         "Remixer"           :   [self.append_ar_singleperson, "was remixed by"],
                         "Lyricist"          :   [self.append_ar_singleperson, "has lyrics by"],
                         "Producer"          :   [self.append_ar_singleperson, "was produced by"],
                         "Performer"         :   [self.append_ar_singleperson, "was performed by"],
                         "Vocal"             :   [self.append_ar_singleperson, "has vocals performed by"],
                         "Engineer"          :   [self.append_ar_singleperson, "was engineered by"] }

            if self.track[mpx.AttributeId.MB_ARTIST_ID]:
                self.Entities.append(self.track[mpx.AttributeId.MB_ARTIST_ID].get())

            self.html += "<div style='height: 2em; margin-bottom: 1em; padding-left: 0.5em; background-color: #909090; color: black; font-size: 1.5em;font-weight: bold'><p style='line-height: 2em'>This Track...</p></div>"
            for rel in Relations:
                if rel in CallTable:
                    CallInfo = CallTable[rel] 
                    if len(CallInfo) == 2:
                        CallInfo[0](Relations[rel], CallInfo[1])
                    else:
                        CallInfo[0](Relations[rel])
                    self.html += "<br/>"

                else:
                    print "TRACKINFO-WEBKIT: Unhandled AR of type: " + rel

            self.html += "<div style='height: 2em; margin-bottom: 1em; padding-left: 0.5em; background-color: #909090; color: black; font-size: 1.5em;font-weight: bold'><p style='line-height: 2em'>Album Links</p></div>"

            if self.track[mpx.AttributeId.ALBUM_ARTIST] and self.track[mpx.AttributeId.ALBUM]: 
                self.html += "<a href='http://rateyourmusic.com/release/album/%s/%s/'>RateYourMusic</a><br/><br/>" % (self.track[mpx.AttributeId.ALBUM_ARTIST].get().replace(" ","_").lower(), self.track[mpx.AttributeId.ALBUM].get().replace(" ","_").lower())

            if self.track[mpx.AttributeId.MB_ALBUM_ID] and self.track[mpx.AttributeId.MB_ALBUM_ID]: 

                try:
                        entity = self.query.getReleaseById(self.track[mpx.AttributeId.MB_ALBUM_ID].get(), self.wsinc_release)
                        rels = entity.getRelations()
                        if len(rels) > 0:
                            self.html += displayRelations(rels)
                except:
                        print "TRACKINFO-WEBKIT: MusicBrainz WS error #2" 

            self.Entities = dict(zip(self.Entities,self.Entities)).keys() 

            try:
                    if len(self.Entities) > 0:
                        self.html += "<div style='height: 2em; margin-bottom: 1em; padding-left: 0.5em; background-color: #909090; color: black; font-size: 1.5em;font-weight: bold'><p style='line-height: 2em'>Contributor Links</p></div>"
                        self.html += "<table>"
                        for id in self.Entities:
                            entity = self.query.getArtistById(id, self.wsinc)   
                            self.html += "<tr><td><b>%s</b></td><td>" % entity.getName()
                            self.html += displayRelations(entity.getRelations())
                            self.html += "</td></tr>"
                        self.html += "</table>"
            except:
                    print "TRACKINFO-WEBKIT: MusicBrainz WS error #3" 

        self.finished.set()

    def getEntityLink(self, entityName, entityId, entityType):

        tuple = [("id", entityId), ("name", entityName.replace("+", " ")), ("type", entityType)]
        return "<a href=\"mpx:///?%s\">%s</a>" % (urllib.urlencode(tuple), entityName)

    def append_ar_coverversion(self, Relations):

        Covers = []
        Output = []

        for Rel in Relations:

            # Workaround for buggy pymusicbrainz; getTarget() on this rel returns None
            Cover = self.query.getTrackById(realId(Rel.getTargetId()), self.wsinc)  
            CoverArtist = Cover.getArtist()
            Covers.append([Cover.getTitle(), CoverArtist.getName(), realId(CoverArtist.getId())])

        for Cover in Covers:

            Output.append("<b>%s</b> by <b>%s</b>" % (Cover[0], self.getEntityLink(Cover[1],Cover[2],"artist")))

        self.html += "...is a cover of %s<br/>" % (", ".join(Output))
        return True

    def append_ar_instrument(self, Relations):

        for Rel in Relations:

            pre, sep, instrument = Rel.getAttributes()[0].partition("#")
            artist = Rel.getTarget()
            self.html += "...has <b>%s</b> performed by <b>%s</b><br/>" % (instrument, self.getEntityLink(artist.getName(),realId(artist.getId()),"artist")) 
            self.Entities.append(realId(artist.getId()))

        return True

    def append_ar_samplesmaterial(self, Relations):

        Sampled = []
        Output = []

        for Rel in Relations:

            Track = self.query.getTrackById(realId(Rel.getTargetId()), self.wsinc)

            SampledArtist = Track.getArtist()
            self.Entities.append(realId(SampledArtist.getId()))
            Sampled.append([Track.getTitle(), SampledArtist.getName(), realId(SampledArtist.getId())])

        for Sample in Sampled:

            Output.append("<b>%s</b> by <b>%s</b>" % (Sample[0], self.getEntityLink(Sample[1],Sample[2],"artist")))

        self.html += "...contains samples from %s<br/>" % (", ".join(Output))
        return True

    def append_ar_singleperson(self, Relations, text):

        Entities = []
        Output = []

        for Rel in Relations:

            self.Entities.append(realId(Rel.getTargetId()))
            Entity = Rel.getTarget() 
            Entities.append([Entity.getName(),realId(Entity.getId())])

        for Entity in Entities:

            Output.append("<b>"+self.getEntityLink(Entity[0],Entity[1],"artist")+"</b>")

        self.html += "...%s %s<br/>" % (text, ", ".join(Output))
        return True

class TrackInfo:

    def __init__(self, xml):

        self.query = ws.Query(musicbrainz2.webservice.WebService("www.uk.musicbrainz.org"))
        self.wsinc = musicbrainz2.webservice.TrackIncludes(trackRelations=True,artist=True,puids=True,releases=True,artistRelations=True,releaseRelations=True,urlRelations=True)
        self.wsinc_release = musicbrainz2.webservice.ReleaseIncludes(releaseEvents=True,releaseRelations=True,urlRelations=True)

        self.xml = xml

        self.notebook = self.xml.get_widget("notebook-track-info")

        self.progress = self.xml.get_widget("progress")
        self.alignment = self.xml.get_widget("alignment")

        self.entry = self.xml.get_widget("entry")
        self.entry.connect("activate", self.on_web_nav_entry_activate)

        self.bback = self.xml.get_widget("b-back")
        self.bback.connect("clicked", self.on_web_nav_go_back)

        self.bffwd = self.xml.get_widget("b-forward")
        self.bffwd.connect("clicked", self.on_web_nav_go_forward)

        self.progress_web = self.xml.get_widget("progress-web")

        self.webview = webkit.WebView()
        self.webview.show_all()
        self.webview.connect("navigation-requested", self.on_webkit_navigation_requested)
        self.webview.connect("title-changed", self.on_webkit_title_changed)
        self.webview.connect("load-progress-changed", self.on_webkit_progress_changed)
        self.webview.connect("load-finished", self.on_webkit_load_finished)

        self.alignment.add(self.webview)
        self.throb = self.xml.get_widget("throb")
        self.throb.set_from_file("@DATA_DIR@" + "/images/throbber.gif")
        self.notebook.set_current_page(0)

        self.player = gst.Pipeline("player")
        self.source = gst.element_factory_make("giosrc", "file-source")
        self.player.add(self.source)
        self.demuxer = gst.element_factory_make("decodebin", "demuxer")
        self.player.add(self.demuxer)
        self.demuxer.connect("new-decoded-pad", self.demuxer_callback)
        self.puid = gst.element_factory_make("puid", "puid")
        self.player.add(self.puid)
        self.gotPuid = threading.Event() 
        self.puid.set_property('musicdns-id', '234e8289d5a5fd4b29127bd114309954')
        self.audiosink = gst.element_factory_make("fakesink", "audio-output")
        self.player.add(self.audiosink)

        gst.element_link_many(self.source, self.demuxer)
        gst.element_link_many(self.puid, self.audiosink)

        self.bus = self.player.get_bus()
        self.bus.add_signal_watch()
        self.bus.connect('message', self.on_gst_bus_message)

    def demuxer_callback(self, demuxer, pad, arg):

        dec_pad = self.puid.get_pad("sink")
        pad.link(dec_pad)
    
    def display_pipeline_duration(self):

        position, format = self.player.query_position(gst.FORMAT_TIME)
        frac = float(position) / float(135000000000)
        if (frac >= 0.) and (frac <= 1.0): 
            self.progress.set_fraction(frac)

        if self.gotPuid.isSet():
            self.progress.set_fraction(0.)
            self.progress.hide()
            return False
        else:
            return True

    def on_gst_bus_message(self, bus, message):    

        t = message.type
        if t == gst.MESSAGE_EOS:
            puid = self.puid.get_property('puid')
            if puid and len(puid) > 0:
                result = ws.TrackFilter(puid=puid) 
                tracks = self.query.getTracks(result)

                if len(tracks) > 0:

                    self.track[mpx.AttributeId.MB_TRACK_ID].set_string(str(tracks[0].getTrack().getId()))

                    mbtrack = self.query.getTrackById(tracks[0].getTrack().getId(), self.wsinc) 
                    artist = mbtrack.getArtist()

                    self.track[mpx.AttributeId.MB_ARTIST_ID].set_string(str(artist.getId()))

                    if not self.track[mpx.AttributeId.ARTIST]:
                        self.track[mpx.AttributeId.ARTIST].set_string(str(artist.getName()))
                    
                    if not self.track[mpx.AttributeId.TITLE]:
                        self.track[mpx.AttributeId.TITLE].set_string(str(mbtrack.getTitle()))

            self.gotPuid.set()
    
    def run(self,track):

        self.track = track

        if not self.gotPuid.isSet() and not track[mpx.AttributeId.MB_TRACK_ID] and track.get(mpx.AttributeId.LOCATION).get()[:7] == "file://":

            self.player.get_by_name("file-source").set_property('location', track.get(mpx.AttributeId.LOCATION).get())
            self.player.set_state(gst.STATE_PLAYING)
            
            gobject.timeout_add (500, self.display_pipeline_duration)
            self.progress.show_all() 

            while not self.gotPuid.isSet():
                while gtk.events_pending():
                    gtk.main_iteration()

            self.gotPuid.clear()

        self.webview.open("mpx:///?type=track")

    def display_track(self, track):

        self.notebook.set_current_page(1)

        t = TrackInfoQuery (track, self.query, self.wsinc, self.wsinc_release)
        t.start()

        while not t.is_done().isSet():
            while gtk.events_pending():
                gtk.main_iteration()

        t.stop()

        self.webview.load_html_string(t.get_html(), "") 

        self.notebook.set_current_page(2)

        # In case we get called by g_idle
        return False

    def display_artist(self, mydict):

        self.notebook.set_current_page(1)

        t = ArtistInfoQuery (mydict["id"], mydict["name"], self.query, self.wsinc, self.wsinc_release)
        t.start()

        while not t.is_done():
            while gtk.events_pending():
                gtk.main_iteration()

        t.stop()

        self.webview.load_html_string(t.get_html(), "") 
        self.notebook.set_current_page(2)

        # In case we get called by g_idle
        return False

    def clear(self):

        self.webview.load_html_string("","")
        self.notebook.set_current_page(0)

    def uriParse(self, uri):

        mydict = {}

        try:
                pre, sep, post = uri.partition("?")        
                segments = string.split(post,"&") 
             
                for segment in segments:

                    splitsegment = string.split(segment,"=")
                    mydict[splitsegment[0]] = splitsegment[1]
        except:
                pre, sep, post = uri.partition("?")        
                splitsegment = string.split(post,"=")
                mydict[splitsegment[0]] = splitsegment[1]

        return mydict

    def openUri(self, uri):

        print "TRACKINFO-WEBKIT: OPENING: " + uri
    
        if uri == "about:blank":

                self.display_track( self.track )
                return

        mydict = self.uriParse(uri) 

        try:
                if mydict["type"] == "artist":
           
                        self.display_artist( mydict )
                        return

                if mydict["type"] == "track":
               
                        self.display_track( self.track ) 
                        return
        except:
                print "TRACKINFO-WEBKIT: openUri exception" 

    def on_webkit_navigation_requested(self, webview, webframe, request):
    
        self.current_uri = request.get_uri()
        self.openUri(self.current_uri)
        return webkit.NAVIGATION_RESPONSE_ACCEPT

    def on_webkit_title_changed(self, webview, frame, title):

        self.current_uri = frame.get_uri()
        self.entry.props.text = self.current_uri

    def on_webkit_progress_changed(self, page, progress):

        self.progress_web.set_fraction(float(progress)/100.)

    def on_webkit_load_finished(self, page, frame):

        self.bback.set_sensitive(self.webview.can_go_back())
        self.bffwd.set_sensitive(self.webview.can_go_forward())

    def on_web_nav_go_back(self, button):

        self.webview.go_back()
        self.bback.set_sensitive(self.webview.can_go_back())
        self.bffwd.set_sensitive(self.webview.can_go_forward())

    def on_web_nav_go_forward(self, button):

        self.webview.go_forward()
        self.bback.set_sensitive(self.webview.can_go_back())
        self.bffwd.set_sensitive(self.webview.can_go_forward())

    def on_web_nav_entry_activate(self, entry):

        self.webview.open(entry.props.text)

class TrackInfoDispatcher(mpx.Plugin):

    """The Trackinfo Plugin provides a Last.fm/Musicbrainz based track info for the currently played track."""

    def __init__(self,id,player,mcs):
    
        self.id = id
        self.player = player
        self.xml = gtk.glade.XML("@DATA_DIR@" + "/python-plugins/trackinfo-webkit/trackinfo-webkit.glade")
        self.vbox = self.xml.get_widget("vbox")
        self.vbox.unparent()

    def activate(self):

        self.player_infoarea_click_id = self.player.gobj().connect("infoarea-click", self.new_track)
        self.player_playstatus_changed_id = self.player.gobj().connect("play-status-changed", self.pstate_changed)
        self.info = TrackInfo(self.xml)
        self.player.add_info_widget(self.vbox, "Track Info")
        return True

    def deactivate(self):
        self.player.remove_info_widget(self.vbox)
        self.player.gobj().disconnect(self.player_infoarea_click_id)
        self.player.gobj().disconnect(self.player_playstatus_changed_id)
        self.info = None

    def pstate_changed(self, blah, state):

        if self.player.get_status() == mpx.PlayStatus.STOPPED:
            self.info.clear()

    def new_track(self, blah):
        try:
            m = self.player.get_metadata()
            self.info.run(m)
        except:
            print "TRACKINFO-WEBKIT: Error runing TrackInfo" 

