
# -*- coding: utf-8 -*-
# -*- mode:python ; tab-width:4 -*- ex:set tabstop=4 shiftwidth=4 expandtab: -*-
#
# MPX Trackinfo
# (C) 2008 M. Derezynski
#

from gettext import gettext as _
from mako.template import Template
from musicbrainz2.model import *
import copy
import gobject
import gst
import gtk
import gtk.glade
import httplib
import locale
import logging
import mpx
import musicbrainz2
import musicbrainz2.webservice as ws
import os
import pango
import pygst
import pygtk
import re
import string
import threading
import time
import time
import urllib
import urllib2
import webkit
import xmlrpclib

# Templates

tmpl_section_header = '''
<div style='height: 2em; margin-top: 1.5em; margin-bottom: 0.7em; padding-left: 0.5em; background-color: #1d6ac8; color: white; font-size: 1.5em;font-weight: bold'><p style='line-height: 2em'>${header}</p></div>
'''

class WebToolbar(gtk.Toolbar):
    def __init__(self, browser):
        gtk.Toolbar.__init__(self)

        self._browser = browser

        # navigational buttons
        self._back = gtk.ToolButton(gtk.STOCK_GO_BACK)
        self._back.set_tooltip(gtk.Tooltips(),_('Back'))
        self._back.props.sensitive = False
        self._back.connect('clicked', self._go_back_cb)
        self.insert(self._back, -1)

        self._forward = gtk.ToolButton(gtk.STOCK_GO_FORWARD)
        self._forward.set_tooltip(gtk.Tooltips(),_('Forward'))
        self._forward.props.sensitive = False
        self._forward.connect('clicked', self._go_forward_cb)
        self.insert(self._forward, -1)
        self._forward.show()

        self._stop_and_reload = gtk.ToolButton(gtk.STOCK_REFRESH)
        self._stop_and_reload.set_tooltip(gtk.Tooltips(),_('Stop and reload current page'))
        self._stop_and_reload.connect('clicked', self._stop_and_reload_cb)
        self.insert(self._stop_and_reload, -1)
        self._stop_and_reload.show()
        self._loading = False

        self.insert(gtk.SeparatorToolItem(), -1)

        # zoom buttons
        self._zoom_in = gtk.ToolButton(gtk.STOCK_ZOOM_IN)
        self._zoom_in.set_tooltip(gtk.Tooltips(), _('Zoom in'))
        self._zoom_in.connect('clicked', self._zoom_in_cb)
        self.insert(self._zoom_in, -1)
        self._zoom_in.show()

        self._zoom_out = gtk.ToolButton(gtk.STOCK_ZOOM_OUT)
        self._zoom_out.set_tooltip(gtk.Tooltips(), _('Zoom out'))
        self._zoom_out.connect('clicked', self._zoom_out_cb)
        self.insert(self._zoom_out, -1)
        self._zoom_out.show()

        self._zoom_hundred = gtk.ToolButton(gtk.STOCK_ZOOM_100)
        self._zoom_hundred.set_tooltip(gtk.Tooltips(), _('100% zoom'))
        self._zoom_hundred.connect('clicked', self._zoom_hundred_cb)
        self.insert(self._zoom_hundred, -1)
        self._zoom_hundred.show()

        self.insert(gtk.SeparatorToolItem(), -1)

        # location entry
        self._entry = gtk.Entry()
        self._entry.connect('activate', self._entry_activate_cb)
        self._current_uri = None

        entry_item = gtk.ToolItem()
        entry_item.set_expand(True)
        entry_item.add(self._entry)
        self._entry.show()

        self.insert(entry_item, -1)
        entry_item.show()

        # scale other content besides from text as well
        # self._browser.set_full_content_zoom(True)

        self._browser.connect("title-changed", self._title_changed_cb)

    def get_entry(self):

        return self._entry

    def set_loading(self, loading):
        self._loading = loading

        if self._loading:
            self._show_stop_icon()
            self._stop_and_reload.set_tooltip(gtk.Tooltips(),_('Stop'))
        else:
            self._show_reload_icon()
            self._stop_and_reload.set_tooltip(gtk.Tooltips(),_('Reload'))
        self._update_navigation_buttons()

    def _set_address(self, address):
        self._entry.props.text = address
        self._current_uri = address

    def _update_navigation_buttons(self):
        can_go_back = self._browser.can_go_back()
        self._back.props.sensitive = can_go_back

        can_go_forward = self._browser.can_go_forward()
        self._forward.props.sensitive = can_go_forward

    def _entry_activate_cb(self, entry):
        self._browser.open(entry.props.text)

    def _go_back_cb(self, button):
        self._browser.go_back()

    def _go_forward_cb(self, button):
        self._browser.go_forward()

    def _title_changed_cb(self, widget, frame, title):
        self._set_address(frame.get_uri())

    def _stop_and_reload_cb(self, button):
        if self._loading:
            self._browser.stop_loading()
        else:
            self._browser.reload()

    def _show_stop_icon(self):
        self._stop_and_reload.set_stock_id(gtk.STOCK_CANCEL)

    def _show_reload_icon(self):
        self._stop_and_reload.set_stock_id(gtk.STOCK_REFRESH)

    def _zoom_in_cb (self, widget):
        """Zoom into the page"""
        self._browser.zoom_in()

    def _zoom_out_cb (self, widget):
        """Zoom out of the page"""
        self._browser.zoom_out()

    def _zoom_hundred_cb (self, widget):
        """Zoom 100%"""
        if not (self._browser.get_zoom_level() == 1.0):
            self._browser.set_zoom_level(1.0);

class BrowserPage(webkit.WebView):
    def __init__(self):
	    webkit.WebView.__init__(self)

class WebStatusBar(gtk.Statusbar):
    def __init__(self):
        gtk.Statusbar.__init__(self)
        self.iconbox = gtk.EventBox()
        self.iconbox.add(gtk.image_new_from_stock(gtk.STOCK_INFO, gtk.ICON_SIZE_BUTTON))
        self.pack_start(self.iconbox, False, False, 6)
        self.iconbox.hide_all()

    def display(self, text, context=None):
        cid = self.get_context_id("pywebkitgtk")
        self.push(cid, str(text))

    def show_javascript_info(self):
        self.iconbox.show()

    def hide_javascript_info(self):
        self.iconbox.hide()


class WebBrowser():

    def __init__(self):

        logging.debug("initializing web browser window")

        self._loading = False
        self._browser= BrowserPage()
        self._browser.connect('load-started', self._loading_start_cb)
        self._browser.connect('load-progress-changed', self._loading_progress_cb)
        self._browser.connect('load-finished', self._loading_stop_cb)
        self._browser.connect("title-changed", self._title_changed_cb)
        self._browser.connect("hovering-over-link", self._hover_link_cb)
        self._browser.connect("status-bar-text-changed", self._statusbar_text_changed_cb)
        self._browser.connect("icon-loaded", self._icon_loaded_cb)
        self._browser.connect("selection-changed", self._selection_changed_cb)
        self._browser.connect("set-scroll-adjustments", self._set_scroll_adjustments_cb)
#        self._browser.connect("populate-popup", self._populate_popup)
#        self._browser.connect("navigation-requested", self._navigation_requested_cb)

        self._browser.connect("console-message",
                              self._javascript_console_message_cb)
        self._browser.connect("script-alert",
                              self._javascript_script_alert_cb)
        self._browser.connect("script-confirm",
                              self._javascript_script_confirm_cb)
        self._browser.connect("script-prompt",
                              self._javascript_script_prompt_cb)

        self._scrolled_window = gtk.ScrolledWindow()
        self._scrolled_window.props.hscrollbar_policy = gtk.POLICY_AUTOMATIC
        self._scrolled_window.props.vscrollbar_policy = gtk.POLICY_AUTOMATIC
        self._scrolled_window.add(self._browser)
        self._scrolled_window.show_all()

        self._toolbar = WebToolbar(self._browser)

        self._statusbar = WebStatusBar()

        self._vbox = gtk.VBox(spacing=4)
        self._vbox.pack_start(self._toolbar, expand=False, fill=False)
        self._vbox.pack_start(self._scrolled_window)
        #self._vbox.pack_end(self._statusbar, expand=False, fill=False)
        self._vbox.show_all()

    def get_entry(self):

        return self._toolbar.get_entry()

    def get_gui(self):

        return self._vbox

    def get_webview(self):

        return self._browser

    def _loading_start_cb(self, page, frame):
        main_frame = self._browser.get_main_frame()
        self._toolbar.set_loading(True)

    def _loading_stop_cb(self, page, frame):
        # FIXME: another frame may still be loading?
        self._toolbar.set_loading(False)

    def _loading_progress_cb(self, page, progress):
        self._set_progress(_("%s%s loaded") % (progress, '%'))

    def _set_progress(self, progress):
        self._statusbar.display(progress)

    def _title_changed_cb(self, widget, frame, title):
        pass 

    def _hover_link_cb(self, page, title, url):
    	if page and url:
	        self._statusbar.display(url)
	    else:
 	        self._statusbar.display('')

    def _statusbar_text_changed_cb(self, page, text):
        #if text:
        self._statusbar.display(text)

    def _icon_loaded_cb(self):
        print "icon loaded"

    def _selection_changed_cb(self):
        print "selection changed"

    def _set_scroll_adjustments_cb(self, page, hadjustment, vadjustment):
        self._scrolled_window.props.hadjustment = hadjustment
        self._scrolled_window.props.vadjustment = vadjustment

    def _javascript_console_message_cb(self, page, message, line, sourceid):
        self._statusbar.show_javascript_info()

    def _javascript_script_alert_cb(self, page, frame, message):
        pass

    def _javascript_script_confirm_cb(self, page, frame, message, isConfirmed):
        pass

    def _javascript_script_prompt_cb(self, page, frame, message, default, text):
        pass

    def _populate_popup(self, view, menu):
        aboutitem = gtk.MenuItem(label="About PyWebKit")
        menu.append(aboutitem)
        aboutitem.connect('activate', self._about_pywebkitgtk_cb)
        menu.show_all()

    def _about_pywebkitgtk_cb(self, widget):
        self._browser.open("http://live.gnome.org/PyWebKitGtk")




def realId(entityId):

    if (entityId[:7] == "http://"):
        return string.split(entityId,"/")[-1]
    else:
        return entityId

def getEntityLink(entityName, entityId, entityType):

    tuple = [("id", realId(entityId)), ("name", entityName.replace("+", " ")), ("type", entityType)]
    return "<a href=\"mpx-info:///?%s\">%s</a>" % (urllib.urlencode(tuple), entityName)

class NoArtistInfoException(Exception):

    def __init__(self):

        Exception.__init__(self)

def getLastFMArtistInfo(artistname):
    
        svr = xmlrpclib.Server("http://ws.audioscrobbler.com/1.0/rw/xmlrpc.php")
        artist = svr.artistMetadata(artistname, locale.getdefaultlocale()[0][:2])
        return artist

def append_url_rels(entity): 

    html        = ""
    mapping     = {
                    "Discogs"           :   "Discogs Link",
                    "Wikipedia"         :   "Wikipedia Link",
                    "Myspace"           :   "Myspace Website",
                    "OfficialHomepage"  :   "Band Homepage"
                  }
    rel_links   = {}
    links       = []
    rels        = entity.getRelations(Relation.TO_URL)

    for rel in rels:

        mbns, hash, reltype = rel.getType().partition("#")
        try:
            rel_links[reltype].append(rel)
        except:
            rel_links[reltype] = []
            rel_links[reltype].append(rel)

    for a in rel_links:

        if a in mapping:

            rls = rel_links[a]
            for rel in rls:
                if len(rls) > 1:
                    links.append("<a href='%s'>%s</a>(%s)" % (rel.getTargetId(), mapping[a], str(rls.index(rel)+1)))
                else:
                    links.append("<a href='%s'>%s</a>" % (rel.getTargetId(), mapping[a]))

    return "  ".join(links) 

def append_artist_rels(entity): 

    data        = []
    relations   = entity.getRelations(Relation.TO_ARTIST)

    for rel in relations:

        mbns, hash, reltype = rel.getType().partition("#")

        if reltype == "MemberOfBand":

            if rel.getDirection() == Relation.DIR_BACKWARD:

                target = rel.getTarget() 
                data.append("...has member <b>%s</b>" % (getEntityLink(target.getName(),target.getId(),"artist")))

            elif rel.getDirection() == Relation.DIR_FORWARD:

                target = rel.getTarget() 
                data.append("...is member in <b>%s</b>" % (getEntityLink(target.getName(),target.getId(),"artist")))

    return "<br/>".join(data)
                
class ArtistInfoQuery (threading.Thread):

    def __init__ (self, artistid, artistname, query, wsinc, wsinc_release): 

        self.query = query 
        self.wsinc = wsinc 
        self.wsinc_release = wsinc_release 

        threading.Thread.__init__(self)
        self.finished = threading.Event()
        self.artistid = artistid
        self.artistname = artistname.replace("+", " ")
        self.html = ""

    def is_done(self):

        return self.finished.isSet()

    def get_html(self):

        return self.html

    def stop (self):

        self.finished.set()
        self.join()

    def run (self):

        try:
                artist_info = getLastFMArtistInfo(self.artistname)
                self.html += Template(tmpl_section_header).render(header=_('About %s') % self.artistname)
                self.html += artist_info["wikiText"] 
                self.html += "  <a href='%s'>...[more]</a></div>" % artist_info["wikiPageUrl"]

                if artist_info["similar"] and len(artist_info["similar"]):
                        e = []
                        for a in artist_info["similar"]:
                            e.append(getEntityLink(a, "", "artist"))

                self.html += "<p><b>Similar Artists: </b>%s</p>" % ", ".join(e)
        except:
                print "Error in ArtistInfoQuery: artist information"

        self.html += Template(tmpl_section_header).render(header=_('Contributor Links'))

        try:
                entity = self.query.getArtistById(self.artistid, self.wsinc)   
                self.html += "<b>%s</b>(%s): <br/>" % (entity.getName(), self.artistid)
                self.html += append_artist_rels(entity)
                self.html += "<br/>"
                self.html += append_url_rels(entity)
        except:
                print "TRACKINFO-WEBKIT: No Last.fm artist info" 

        self.finished.set()

class TrackInfoQuery (threading.Thread):

    def __init__ (self, track, query, wsinc, wsinc_release): 

        self.query = query
        self.wsinc = wsinc 
        self.wsinc_release = wsinc_release 

        threading.Thread.__init__(self)
        self.finished = threading.Event()
        self.track = track
        self.html = ""

    def is_done(self):

        return self.finished

    def get_html(self):

        return self.html

    def stop (self):

        self.finished.set()
        self.join()

    def run (self):

        # Artist Info

        try:
                artist_info = getLastFMArtistInfo(self.track[mpx.AttributeId.ARTIST].get())
                self.html += Template(tmpl_section_header).render(header='About %s' % self.track[mpx.AttributeId.ARTIST].get())
                self.html += artist_info["wikiText"] 
                self.html += "<a href='%s'>[more]</a></div>" % artist_info["wikiPageUrl"]
                if artist_info["similar"] and len(artist_info["similar"]):
                        e = []
                        for a in artist_info["similar"]:
                            e.append(getEntityLink(a, "", "artist"))

                self.html += "<p><b>Similar Artists: </b>%s</p>" % ", ".join(e)
        except:
                print "Error in TrackInfoQuery: artist information"

        # Lyrics

        try:
                req  = urllib2.urlopen("http://lyricwiki.org/api.php?fmt=text&artist=%s&song=%s"
                        % (urllib.quote(self.track[mpx.AttributeId.ARTIST].get()), urllib.quote(self.track[mpx.AttributeId.TITLE].get())))
                lyrics = req.read()
                if lyrics != "Not found":
                    self.html += Template(tmpl_section_header).render(header='Lyrics')
                    self.html += lyrics.replace("\n","<br/>")
        except:
                print "TRACKINFO-WEBKIT: Error fetching lyrics" 

        # MB-based Track Info

        if self.track[mpx.AttributeId.MB_TRACK_ID]:

            # Variables

            CallTable = {"Cover"             :   [self.append_ar_coverversion],
                         "Instrument"        :   [self.append_ar_instrument],
                         "SamplesMaterial"   :   [self.append_ar_samplesmaterial],
                         "Composer"          :   [self.append_ar_singleperson, "was composed by"],
                         "Remixer"           :   [self.append_ar_singleperson, "was remixed by"],
                         "Lyricist"          :   [self.append_ar_singleperson, "has lyrics by"],
                         "Producer"          :   [self.append_ar_singleperson, "was produced by"],
                         "Performer"         :   [self.append_ar_singleperson, "was performed by"],
                         "Vocal"             :   [self.append_ar_singleperson, "has vocals performed by"],
                         "Engineer"          :   [self.append_ar_singleperson, "was engineered by"],
                         "Mix"               :   [self.append_ar_singleperson, "was mixed by"],
                         "Programming"       :   [self.append_ar_singleperson, "was programmed by"],
                         "Recording"         :   [self.append_ar_singleperson, "was recorded by"] }

            Relations = {}
            Entities  = []

            if self.track[mpx.AttributeId.MB_ARTIST_ID]:
                Entities.append(self.track[mpx.AttributeId.MB_ARTIST_ID].get())

            # Get MB Track Info

            try:
                    TrackId = self.track.get(mpx.AttributeId.MB_TRACK_ID).get()
                    mbTrack = self.query.getTrackById(TrackId, self.wsinc) 
            except:
                    print "TRACKINFO-WEBKIT: MusicBrainz WS error"
                    self.finished.set()
                    return

            mbRelations = mbTrack.getRelations()

            for Relation in mbRelations:

                    if Relation.getDirection() != "backward":
        
                            x,y,relation_type = Relation.getType().partition("#")

                            try:
                                    Relations[relation_type].append(Relation)
                            except:
                                    Relations[relation_type] = [Relation]

            # 'This Track...' info/details

            if len(Relations):

                    self.html += Template(tmpl_section_header).render(header=_('This Track...'))

                    for rel in Relations:
                        if rel in CallTable:
                            CallInfo = CallTable[rel] 
                            if len(CallInfo) == 2:
                                CallInfo[0](Entities, Relations[rel], CallInfo[1])
                            else:
                                CallInfo[0](Entities, Relations[rel])

                            self.html += "<br/>"

                        else:
                            print "TRACKINFO-WEBKIT: Unhandled AR of type: " + rel

            # Album Links

            album_links_text = ""
    
            self.html += Template(tmpl_section_header).render(header=_('Album Links'))

            if self.track[mpx.AttributeId.ALBUM_ARTIST] and self.track[mpx.AttributeId.ALBUM]: 
                album_links_text += "<a href='http://rateyourmusic.com/release/album/%s/%s/'>RateYourMusic</a>  " % (self.track[mpx.AttributeId.ALBUM_ARTIST].get().replace(" ","_").lower(), self.track[mpx.AttributeId.ALBUM].get().replace(" ","_").lower())

            if self.track[mpx.AttributeId.MB_ALBUM_ID] and self.track[mpx.AttributeId.MB_ALBUM_ID]: 

                try:
                    album_links_text += append_url_rels(self.query.getReleaseById(self.track[mpx.AttributeId.MB_ALBUM_ID].get(), self.wsinc_release))
                except:
                    print "TRACKINFO-WEBKIT: MusicBrainz WS error #2" 


            # Contributor Links

            Entities = dict(zip(Entities,Entities)).keys() 

            try:
                if len(Entities) > 0:

                    self.html += Template(tmpl_section_header).render(header=_('Contributor Links'))

                    for id in Entities:

                        entity = self.query.getArtistById(id, self.wsinc)   

                        self.html += "<span style='font-weight:bold; font-size: large'>%s</span>" % entity.getName()

                        self.html += "<div style='margin-left: 1em; margin-bottom: 0.5em'>"

                        artist_rels = append_artist_rels(entity)
                        if len(artist_rels):
                            self.html += artist_rels 
                            self.html += "<br/>"
                        self.html += append_url_rels(entity)

                        self.html += "</div>"
            except:
                    print "TRACKINFO-WEBKIT: MusicBrainz WS error #3" 

        self.finished.set()

    def append_ar_coverversion(self, Entities, Relations):

        Covers = []
        Output = []

        for Rel in Relations:

                try:
                        # Workaround for buggy pymusicbrainz; getTarget() on this rel returns None
                        Cover = self.query.getTrackById(realId(Rel.getTargetId()), self.wsinc)  
                        CoverArtist = Cover.getArtist()
                        Covers.append([Cover.getTitle(), CoverArtist.getName(), realId(CoverArtist.getId())])
                except:
                        pass

        for Cover in Covers:

            Output.append("<b>%s</b> by <b>%s</b>" % (Cover[0], getEntityLink(Cover[1],Cover[2],"artist")))

        self.html += "...is a cover of %s" % (", ".join(Output))
        return True

    def append_ar_instrument(self, Entities, Relations):

        for Rel in Relations:

                try:
                        attr = Rel.getAttributes()
                        artist = Rel.getTarget()

                        if len(attr) == 1:

                                pre, sep, instrument = Rel.getAttributes()[0].partition("#")
                                self.html += "...has <b>%s</b> performed by <b>%s</b>" % (instrument, getEntityLink(artist.getName(),realId(artist.getId()),"artist")) 
                                Entities.append(realId(artist.getId()))

                        elif len(attr) == 2:

                                pre, sep, adjective = Rel.getAttributes()[0].partition("#")
                                pre, sep, instrument = Rel.getAttributes()[1].partition("#")
                                self.html += "...has <b>%s %s</b> performed by <b>%s</b>" % (adjective.lower(), instrument, getEntityLink(artist.getName(),realId(artist.getId()),"artist")) 
                                Entities.append(realId(artist.getId()))

                        elif len(attr) == 3:
                
                                pre, sep, adjective2 = Rel.getAttributes()[0].partition("#")
                                pre, sep, adjective1 = Rel.getAttributes()[1].partition("#")
                                pre, sep, instrument = Rel.getAttributes()[2].partition("#")
                                self.html += "...has <b>%s %s %s</b> performed by <b>%s</b>" % (adjective1.lower(), adjective2.lower(), instrument, getEntityLink(artist.getName(),realId(artist.getId()),"artist")) 
                                Entities.append(realId(artist.getId()))

                        if Relations.index(Rel) != (len(Relations)-1):

                                self.html += "<br/>"
                except:
                        pass

        return True

    def append_ar_samplesmaterial(self, Entities, Relations):

        Sampled = []
        Output  = []

        for Rel in Relations:
        
                try:
                        Track = self.query.getTrackById(realId(Rel.getTargetId()), self.wsinc)
                        SampledArtist = Track.getArtist()
                        Entities.append(realId(SampledArtist.getId()))
                        Sampled.append([Track.getTitle(), SampledArtist.getName(), realId(SampledArtist.getId())])
                except:
                        pass

        for Sample in Sampled:

                Output.append("<b>%s</b> by <b>%s</b>" % (Sample[0], getEntityLink(Sample[1],Sample[2],"artist")))

        self.html += "...contains samples from %s" % (", ".join(Output))
        return True

    def append_ar_singleperson(self, Entities, Relations, text):

        Entities_L = []
        Output     = []

        for Rel in Relations:

                try:
                        Entities.append(realId(Rel.getTargetId()))
                        Entity = Rel.getTarget() 
                        Entities_L.append([Entity.getName(),realId(Entity.getId())])
                except:
                        pass

        for Entity in Entities_L:

                Output.append("<b>"+getEntityLink(Entity[0],Entity[1],"artist")+"</b>")

        self.html += "...%s %s" % (text, ", ".join(Output))
        return True

class TrackInfo:

    def __init__(self, xml, mpx):

        self.mpx = mpx

        self.query = ws.Query(musicbrainz2.webservice.WebService("www.uk.musicbrainz.org"))
        self.wsinc = musicbrainz2.webservice.TrackIncludes(trackRelations=True,artist=True,puids=True,releases=True,artistRelations=True,releaseRelations=True,urlRelations=True)
        self.wsinc_release = musicbrainz2.webservice.ReleaseIncludes(releaseEvents=True,releaseRelations=True,urlRelations=True)

        self.notebook = xml.get_widget("notebook")
        self.alignment = xml.get_widget("alignment")
        self.progress = xml.get_widget("progress")

        self.browser = WebBrowser()
        self.webview = self.browser.get_webview()
        self.webview.connect("navigation-requested", self.on_webkit_navigation_requested)

        self.alignment.add_with_viewport(self.browser.get_gui())

        self.throb = xml.get_widget("throbber")
        self.throb.set_from_file("@DATA_DIR@" + "/images/throbber.gif")
        self.notebook.set_current_page(0)

        self.artist_cached = {}

    def run(self,track):

        self.cached_html = None
        self.track = track
        self.webview.open("mpx-info:///?type=track")

    def display_track(self, track):

        if self.cached_html:
            self.webview.load_html_string(self.cached_html, "") 
        else:
            self.notebook.set_current_page(1)
            t = TrackInfoQuery (track, self.query, self.wsinc, self.wsinc_release)
            t.start()

            while not t.is_done().isSet():
                while gtk.events_pending():
                    gtk.main_iteration()

            t.stop()

            self.cached_html = t.get_html()
            self.webview.load_html_string(t.get_html(), "") 
            self.notebook.set_current_page(0)

        # In case we get called by g_idle
        return False

    def display_artist(self, mydict):

        if mydict["name"] in self.artist_cached:
            self.webview.load_html_string(self.artist_cached[mydict["name"]], "") 
        else:
            self.notebook.set_current_page(1)
            t = ArtistInfoQuery (mydict["id"], mydict["name"], self.query, self.wsinc, self.wsinc_release)
            t.start()

            while not t.is_done():
                while gtk.events_pending():
                    gtk.main_iteration()

            t.stop()
            self.artist_cached[mydict["id"]] = t.get_html()
            self.webview.load_html_string(t.get_html(), "") 
            self.notebook.set_current_page(0)

        # In case we get called by g_idle
        return False

    def clear(self):
    
        self.cached_html = None
        self.webview.load_html_string("","")
        self.notebook.set_current_page(0)

    def uriParse(self, uri):

        mydict = {}

        try:
                pre, sep, post = uri.partition("?")        
                segments = string.split(post,"&") 
             
                for segment in segments:

                    splitsegment = string.split(segment,"=")
                    mydict[splitsegment[0]] = splitsegment[1]
        except:
                pre, sep, post = uri.partition("?")        
                splitsegment = string.split(post,"=")
                mydict[splitsegment[0]] = splitsegment[1]

        return mydict

    def openUri(self, uri):

        print "TRACKINFO-WEBKIT: OPENING: " + uri
    
        if uri == "about:blank":
                uri = "mpx-info:///?type=track"

        self.browser.get_entry().props.text = uri
        self.current_uri = uri
    
        mydict = self.uriParse(uri) 

        try:
                if mydict["type"] == "artist":
           
                        self.display_artist( mydict )
                        return

                if mydict["type"] == "track":
               
                        self.display_track( self.track ) 
                        return
        except:
                print "TRACKINFO-WEBKIT: openUri exception" 

    def on_webkit_navigation_requested(self, webview, webframe, request):
    
        self.current_uri = request.get_uri()
        self.openUri(self.current_uri)
        return webkit.NAVIGATION_RESPONSE_ACCEPT


class TrackInfoDispatcher(mpx.Plugin):

    """The Trackinfo Plugin provides a Last.fm/Musicbrainz based track info for the currently played track."""

    def __init__(self,id,player,mcs):
    
        self.id = id
        self.player = player
        self.xml = gtk.glade.XML("@DATA_DIR@" + "/python-plugins/trackinfo-webkit/trackinfo-webkit.glade")
        self.vbox = self.xml.get_widget("vbox")
        self.vbox.unparent()
        self.info = TrackInfo(self.xml,self.player)

    def activate(self):

        self.player_infoarea_click_id = self.player.gobj().connect("metadata-updated", self.metadata_updated)
        self.player_playstatus_changed_id = self.player.gobj().connect("play-status-changed", self.pstate_changed)
        self.player.add_info_widget(self.vbox, "Track Info")

        try:
            self.info.run(self.player.get_metadata())
        except:
            pass # We just try to display it after activation

        return True

    def deactivate(self):
        self.player.remove_info_widget(self.vbox)
        self.player.gobj().disconnect(self.player_infoarea_click_id)
        self.player.gobj().disconnect(self.player_playstatus_changed_id)
        self.info.clear()

    def pstate_changed(self, blah, state):

        if self.player.get_status() == mpx.PlayStatus.STOPPED:
            self.info.clear()

    def metadata_updated(self, blah):

        try:
            self.info.run(self.player.get_metadata())
        except Exception, e:
            print e

 
