
# -*- coding: utf-8 -*-
# -*- mode:python ; tab-width:4 -*- ex:set tabstop=4 shiftwidth=4 expandtab: -*-
#
# MPX Trackinfo
# (C) 2008 M. Derezynski
#

import copy
import gobject
import gst
import gtk
import gtk.glade
import httplib
import mpx
import musicbrainz2
import musicbrainz2.webservice as ws
from musicbrainz2.model import *
import os
import pango
import pygst
import pygtk
import re
import string
import threading
import time
import urllib
import urllib2
import webkit
import libxml2
import logging
import time
from gettext import gettext as _

class WebToolbar(gtk.Toolbar):
    def __init__(self, browser):
        gtk.Toolbar.__init__(self)

        self._browser = browser

        # navigational buttons
        self._back = gtk.ToolButton(gtk.STOCK_GO_BACK)
        self._back.set_tooltip(gtk.Tooltips(),_('Back'))
        self._back.props.sensitive = False
        self._back.connect('clicked', self._go_back_cb)
        self.insert(self._back, -1)

        self._forward = gtk.ToolButton(gtk.STOCK_GO_FORWARD)
        self._forward.set_tooltip(gtk.Tooltips(),_('Forward'))
        self._forward.props.sensitive = False
        self._forward.connect('clicked', self._go_forward_cb)
        self.insert(self._forward, -1)
        self._forward.show()

        self._stop_and_reload = gtk.ToolButton(gtk.STOCK_REFRESH)
        self._stop_and_reload.set_tooltip(gtk.Tooltips(),_('Stop and reload current page'))
        self._stop_and_reload.connect('clicked', self._stop_and_reload_cb)
        self.insert(self._stop_and_reload, -1)
        self._stop_and_reload.show()
        self._loading = False

        self.insert(gtk.SeparatorToolItem(), -1)

        # zoom buttons
        self._zoom_in = gtk.ToolButton(gtk.STOCK_ZOOM_IN)
        self._zoom_in.set_tooltip(gtk.Tooltips(), _('Zoom in'))
        self._zoom_in.connect('clicked', self._zoom_in_cb)
        self.insert(self._zoom_in, -1)
        self._zoom_in.show()

        self._zoom_out = gtk.ToolButton(gtk.STOCK_ZOOM_OUT)
        self._zoom_out.set_tooltip(gtk.Tooltips(), _('Zoom out'))
        self._zoom_out.connect('clicked', self._zoom_out_cb)
        self.insert(self._zoom_out, -1)
        self._zoom_out.show()

        self._zoom_hundred = gtk.ToolButton(gtk.STOCK_ZOOM_100)
        self._zoom_hundred.set_tooltip(gtk.Tooltips(), _('100% zoom'))
        self._zoom_hundred.connect('clicked', self._zoom_hundred_cb)
        self.insert(self._zoom_hundred, -1)
        self._zoom_hundred.show()

        self.insert(gtk.SeparatorToolItem(), -1)

        # location entry
        self._entry = gtk.Entry()
        self._entry.connect('activate', self._entry_activate_cb)
        self._current_uri = None

        entry_item = gtk.ToolItem()
        entry_item.set_expand(True)
        entry_item.add(self._entry)
        self._entry.show()

        self.insert(entry_item, -1)
        entry_item.show()

        # scale other content besides from text as well
        # self._browser.set_full_content_zoom(True)

        self._browser.connect("title-changed", self._title_changed_cb)

    def get_entry(self):

        return self._entry

    def set_loading(self, loading):
        self._loading = loading

        if self._loading:
            self._show_stop_icon()
            self._stop_and_reload.set_tooltip(gtk.Tooltips(),_('Stop'))
        else:
            self._show_reload_icon()
            self._stop_and_reload.set_tooltip(gtk.Tooltips(),_('Reload'))
        self._update_navigation_buttons()

    def _set_address(self, address):
        self._entry.props.text = address
        self._current_uri = address

    def _update_navigation_buttons(self):
        can_go_back = self._browser.can_go_back()
        self._back.props.sensitive = can_go_back

        can_go_forward = self._browser.can_go_forward()
        self._forward.props.sensitive = can_go_forward

    def _entry_activate_cb(self, entry):
        self._browser.open(entry.props.text)

    def _go_back_cb(self, button):
        self._browser.go_back()

    def _go_forward_cb(self, button):
        self._browser.go_forward()

    def _title_changed_cb(self, widget, frame, title):
        self._set_address(frame.get_uri())

    def _stop_and_reload_cb(self, button):
        if self._loading:
            self._browser.stop_loading()
        else:
            self._browser.reload()

    def _show_stop_icon(self):
        self._stop_and_reload.set_stock_id(gtk.STOCK_CANCEL)

    def _show_reload_icon(self):
        self._stop_and_reload.set_stock_id(gtk.STOCK_REFRESH)

    def _zoom_in_cb (self, widget):
        """Zoom into the page"""
        self._browser.zoom_in()

    def _zoom_out_cb (self, widget):
        """Zoom out of the page"""
        self._browser.zoom_out()

    def _zoom_hundred_cb (self, widget):
        """Zoom 100%"""
        if not (self._browser.get_zoom_level() == 1.0):
            self._browser.set_zoom_level(1.0);

class BrowserPage(webkit.WebView):
    def __init__(self):
	    webkit.WebView.__init__(self)

class WebStatusBar(gtk.Statusbar):
    def __init__(self):
        gtk.Statusbar.__init__(self)
        self.iconbox = gtk.EventBox()
        self.iconbox.add(gtk.image_new_from_stock(gtk.STOCK_INFO, gtk.ICON_SIZE_BUTTON))
        self.pack_start(self.iconbox, False, False, 6)
        self.iconbox.hide_all()

    def display(self, text, context=None):
        cid = self.get_context_id("pywebkitgtk")
        self.push(cid, str(text))

    def show_javascript_info(self):
        self.iconbox.show()

    def hide_javascript_info(self):
        self.iconbox.hide()


class WebBrowser():

    def __init__(self):

        logging.debug("initializing web browser window")

        self._loading = False
        self._browser= BrowserPage()
        self._browser.connect('load-started', self._loading_start_cb)
        self._browser.connect('load-progress-changed', self._loading_progress_cb)
        self._browser.connect('load-finished', self._loading_stop_cb)
        self._browser.connect("title-changed", self._title_changed_cb)
        self._browser.connect("hovering-over-link", self._hover_link_cb)
        self._browser.connect("status-bar-text-changed", self._statusbar_text_changed_cb)
        self._browser.connect("icon-loaded", self._icon_loaded_cb)
        self._browser.connect("selection-changed", self._selection_changed_cb)
        self._browser.connect("set-scroll-adjustments", self._set_scroll_adjustments_cb)
#        self._browser.connect("populate-popup", self._populate_popup)
#        self._browser.connect("navigation-requested", self._navigation_requested_cb)

        self._browser.connect("console-message",
                              self._javascript_console_message_cb)
        self._browser.connect("script-alert",
                              self._javascript_script_alert_cb)
        self._browser.connect("script-confirm",
                              self._javascript_script_confirm_cb)
        self._browser.connect("script-prompt",
                              self._javascript_script_prompt_cb)

        self._scrolled_window = gtk.ScrolledWindow()
        self._scrolled_window.props.hscrollbar_policy = gtk.POLICY_AUTOMATIC
        self._scrolled_window.props.vscrollbar_policy = gtk.POLICY_AUTOMATIC
        self._scrolled_window.add(self._browser)
        self._scrolled_window.show_all()

        self._toolbar = WebToolbar(self._browser)

        self._statusbar = WebStatusBar()

        self._vbox = gtk.VBox(spacing=4)
        self._vbox.pack_start(self._toolbar, expand=False, fill=False)
        self._vbox.pack_start(self._scrolled_window)
        #self._vbox.pack_end(self._statusbar, expand=False, fill=False)
        self._vbox.show_all()

    def get_entry(self):

        return self._toolbar.get_entry()

    def get_gui(self):

        return self._vbox

    def get_webview(self):

        return self._browser

    def _loading_start_cb(self, page, frame):
        main_frame = self._browser.get_main_frame()
        self._toolbar.set_loading(True)

    def _loading_stop_cb(self, page, frame):
        # FIXME: another frame may still be loading?
        self._toolbar.set_loading(False)

    def _loading_progress_cb(self, page, progress):
        self._set_progress(_("%s%s loaded") % (progress, '%'))

    def _set_progress(self, progress):
        self._statusbar.display(progress)

    def _title_changed_cb(self, widget, frame, title):
        pass 

    def _hover_link_cb(self, page, title, url):
    	if page and url:
	        self._statusbar.display(url)
	    else:
 	        self._statusbar.display('')

    def _statusbar_text_changed_cb(self, page, text):
        #if text:
        self._statusbar.display(text)

    def _icon_loaded_cb(self):
        print "icon loaded"

    def _selection_changed_cb(self):
        print "selection changed"

    def _set_scroll_adjustments_cb(self, page, hadjustment, vadjustment):
        self._scrolled_window.props.hadjustment = hadjustment
        self._scrolled_window.props.vadjustment = vadjustment

    def _javascript_console_message_cb(self, page, message, line, sourceid):
        self._statusbar.show_javascript_info()

    def _javascript_script_alert_cb(self, page, frame, message):
        pass

    def _javascript_script_confirm_cb(self, page, frame, message, isConfirmed):
        pass

    def _javascript_script_prompt_cb(self, page, frame, message, default, text):
        pass

    def _populate_popup(self, view, menu):
        aboutitem = gtk.MenuItem(label="About PyWebKit")
        menu.append(aboutitem)
        aboutitem.connect('activate', self._about_pywebkitgtk_cb)
        menu.show_all()

    def _about_pywebkitgtk_cb(self, widget):
        self._browser.open("http://live.gnome.org/PyWebKitGtk")




def realId(entityId):

    if (entityId[:7] == "http://"):
        return string.split(entityId,"/")[-1]
    else:
        return entityId

def getEntityLink(entityName, entityId, entityType):

    tuple = [("id", realId(entityId)), ("name", entityName.replace("+", " ")), ("type", entityType)]
    return "<a href=\"mpx-info:///?%s\">%s</a>" % (urllib.urlencode(tuple), entityName)

def getLastFMArtistInfo(artistname):

        request = mpx.LastFMArtistMetadataRequestString(artistname)
        headers = {"Content-Type"   :"text/xml",
                   "Accept"         :"text/utf-8",
                   "User-Agent"     :"MPX-1.0"}
        conn = httplib.HTTPConnection("ws.audioscrobbler.com:80")
        conn.request("POST", "/1.0/rw/xmlrpc.php", request, headers)
        response = conn.getresponse()
        data = response.read()
        conn.close()

        artist = ""

        try:
                doc = libxml2.parseMemory(data,len(data))
                ctx = doc.xpathNewContext()
                res = ctx.xpathEval("//member[name = 'wikiText']/value/string")

                artist = res[0].getContent()
                re1 = re.compile("(\\[[^\\]]+\\])")
                re2 = re.compile("(\\[\\/[^\\]]+\\])")
                artist = re1.sub("",artist)
                artist = re2.sub("",artist)
        except:
                artist = "No artist data on Last.fm"

        return artist

def append_url_rels(entity): 

    html        = ""
    mapping     = {
                    "Discogs"           :   "Discogs Link",
                    "Wikipedia"         :   "Wikipedia Link",
                    "Myspace"           :   "Myspace Website",
                    "OfficialHomepage"  :   "Band Homepage"
                  }
    rel_links   = {}
    links       = []
    rels        = entity.getRelations(Relation.TO_URL)

    for rel in rels:

        mbns, hash, reltype = rel.getType().partition("#")
        try:
            rel_links[reltype].append(rel)
        except:
            rel_links[reltype] = []
            rel_links[reltype].append(rel)

    for a in rel_links:

        if a in mapping:

            rls = rel_links[a]
            for rel in rls:
                if len(rls) > 1:
                    links.append("<a href='%s'>%s</a>(%s)" % (rel.getTargetId(), mapping[a], str(rls.index(rel)+1)))
                else:
                    links.append("<a href='%s'>%s</a>" % (rel.getTargetId(), mapping[a]))

    return "  ".join(links) 

def append_artist_rels(entity): 

    data        = []
    relations   = entity.getRelations(Relation.TO_ARTIST)

    for rel in relations:

        mbns, hash, reltype = rel.getType().partition("#")

        if reltype == "MemberOfBand":

            if rel.getDirection() == Relation.DIR_BACKWARD:

                target = rel.getTarget() 
                data.append("...has member <b>%s</b>" % (getEntityLink(target.getName(),target.getId(),"artist")))

            elif rel.getDirection() == Relation.DIR_FORWARD:

                target = rel.getTarget() 
                data.append("...is member in <b>%s</b>" % (getEntityLink(target.getName(),target.getId(),"artist")))

    return "<br/>".join(data)
                
class ArtistInfoQuery (threading.Thread):

    def __init__ (self, artistid, artistname, query, wsinc, wsinc_release): 

        self.query = query 
        self.wsinc = wsinc 
        self.wsinc_release = wsinc_release 

        threading.Thread.__init__(self)
        self.finished = threading.Event()
        self.artistid = artistid
        self.artistname = artistname.replace("+", " ")
        self.html = ""

    def is_done(self):

        return self.finished.isSet()

    def get_html(self):

        return self.html

    def stop (self):

        self.finished.set()
        self.join()

    def run (self):

        artist = getLastFMArtistInfo(self.artistname)

        self.html += "<div style='height: 2em; margin-bottom: 0.2em; padding-left: 0.5em; background-color: #1d6ac8; color: white; font-size: 1.5em;font-weight: bold'><p style='line-height: 2em'>About %s</p></div>" % self.artistname 
        self.html += artist

        self.html += "<div style='height: 2em; margin-top: 1.5em; margin-bottom: 0.2em; padding-left: 0.5em; background-color: #1d6ac8; color: white; font-size: 1.5em;font-weight: bold'><p style='line-height: 2em'>Contributor Links</p></div>"

        try:
                entity = self.query.getArtistById(self.artistid, self.wsinc)   
                self.html += "<b>%s</b>(%s): <br/>" % (entity.getName(), self.artistid)
                self.html += append_artist_rels(entity)
                self.html += "<br/>"
                self.html += append_url_rels(entity)
        except:
                print "TRACKINFO-WEBKIT: No Last.fm artist info" 

        self.finished.set()

class TrackInfoQuery (threading.Thread):

    def __init__ (self, track, query, wsinc, wsinc_release): 

        self.query = query
        self.wsinc = wsinc 
        self.wsinc_release = wsinc_release 

        threading.Thread.__init__(self)
        self.finished = threading.Event()
        self.track = track
        self.html = ""

    def is_done(self):

        return self.finished

    def get_html(self):

        return self.html

    def stop (self):

        self.finished.set()
        self.join()

    def run (self):

        try:
                artist = getLastFMArtistInfo(self.track[mpx.AttributeId.ARTIST].get())

                self.html += "<div style='height: 2em; margin-top: 1.5em; margin-bottom: 0.2em; padding-left: 0.5em; background-color: #1d6ac8; color: white; font-size: 1.5em;font-weight: bold'><p style='line-height: 2em'>About %s</p></div>" % self.track[mpx.AttributeId.ARTIST].get()
                self.html += artist
        except:
                pass 

        try:
                req  = urllib2.urlopen("http://lyricwiki.org/api.php?fmt=text&artist=%s&song=%s"
                        % (urllib.quote(self.track[mpx.AttributeId.ARTIST].get()), urllib.quote(self.track[mpx.AttributeId.TITLE].get())))
                lyrics = req.read()
                if lyrics != "Not found":
                    self.html += "<div style='height: 2em; margin-top: 1.5em; margin-bottom: 0.2em; padding-left: 0.5em; background-color: #1d6ac8; color: white; font-size: 1.5em;font-weight: bold'><p style='line-height: 2em'>Lyrics</p></div>"
                    self.html += lyrics.replace("\n","<br/>")
        except:
                print "TRACKINFO-WEBKIT: Error fetching lyrics" 

        if self.track[mpx.AttributeId.MB_TRACK_ID]:

            Relations = {}
            self.Entities = []

            try:
                    TrackId = self.track.get(mpx.AttributeId.MB_TRACK_ID).get()
                    MbTrack = self.query.getTrackById(TrackId, self.wsinc) 
            except:
                    print "TRACKINFO-WEBKIT: MusicBrainz WS error"
                    self.finished.set()
                    return;

            MbRelations = MbTrack.getRelations()

            for Relation in MbRelations:

                if Relation.getDirection() != "backward":
    
                    x,y,relation_type = Relation.getType().partition("#")

                    try:
                        Relations[relation_type].append(Relation)
                    except:
                        Relations[relation_type] = [Relation]


            CallTable = {"Cover"             :   [self.append_ar_coverversion],
                         "Instrument"        :   [self.append_ar_instrument],
                         "SamplesMaterial"   :   [self.append_ar_samplesmaterial],
                         "Composer"          :   [self.append_ar_singleperson, "was composed by"],
                         "Remixer"           :   [self.append_ar_singleperson, "was remixed by"],
                         "Lyricist"          :   [self.append_ar_singleperson, "has lyrics by"],
                         "Producer"          :   [self.append_ar_singleperson, "was produced by"],
                         "Performer"         :   [self.append_ar_singleperson, "was performed by"],
                         "Vocal"             :   [self.append_ar_singleperson, "has vocals performed by"],
                         "Engineer"          :   [self.append_ar_singleperson, "was engineered by"] }

            if self.track[mpx.AttributeId.MB_ARTIST_ID]:
                self.Entities.append(self.track[mpx.AttributeId.MB_ARTIST_ID].get())

            self.html += "<div style='height: 2em; margin-top: 1.5em; margin-bottom: 0.2em; padding-left: 0.5em; background-color: #1d6ac8; color: white; font-size: 1.5em;font-weight: bold'><p style='line-height: 2em'>This Track...</p></div>"
            for rel in Relations:
                if rel in CallTable:
                    CallInfo = CallTable[rel] 
                    if len(CallInfo) == 2:
                        CallInfo[0](Relations[rel], CallInfo[1])
                    else:
                        CallInfo[0](Relations[rel])
                    self.html += "<br/>"

                else:
                    print "TRACKINFO-WEBKIT: Unhandled AR of type: " + rel

            self.html += "<div style='height: 2em; margin-top: 1.5em; margin-bottom: 0.2em; padding-left: 0.5em; background-color: #1d6ac8; color: white; font-size: 1.5em;font-weight: bold'><p style='line-height: 2em'>Album Links</p></div>"

            if self.track[mpx.AttributeId.ALBUM_ARTIST] and self.track[mpx.AttributeId.ALBUM]: 
                self.html += "<a href='http://rateyourmusic.com/release/album/%s/%s/'>RateYourMusic</a>  " % (self.track[mpx.AttributeId.ALBUM_ARTIST].get().replace(" ","_").lower(), self.track[mpx.AttributeId.ALBUM].get().replace(" ","_").lower())

            if self.track[mpx.AttributeId.MB_ALBUM_ID] and self.track[mpx.AttributeId.MB_ALBUM_ID]: 

                #try:
                    entity = self.query.getReleaseById(self.track[mpx.AttributeId.MB_ALBUM_ID].get(), self.wsinc_release)
                    self.html += append_url_rels(entity)
                #except:
                #    print "TRACKINFO-WEBKIT: MusicBrainz WS error #2" 

            self.Entities = dict(zip(self.Entities,self.Entities)).keys() 

            try:
                    if len(self.Entities) > 0:
                        self.html += "<div style='height: 2em; margin-top: 1.5em; margin-bottom: 0.2em; padding-left: 0.5em; background-color: #1d6ac8; color: white; font-size: 1.5em;font-weight: bold'><p style='line-height: 2em'>Contributor Links</p></div>"
                        for id in self.Entities:
                            entity = self.query.getArtistById(id, self.wsinc)   
                            self.html += "<span style='font-weight:bold; font-size: large'>%s</span><br/>" % entity.getName()
                            self.html += append_artist_rels(entity)
                            self.html += "<br/>"
                            self.html += append_url_rels(entity)
                            self.html += "<br/><br/>"
            except:
                    print "TRACKINFO-WEBKIT: MusicBrainz WS error #3" 

        self.finished.set()

    def append_ar_coverversion(self, Relations):

        Covers = []
        Output = []

        for Rel in Relations:

            # Workaround for buggy pymusicbrainz; getTarget() on this rel returns None
            Cover = self.query.getTrackById(realId(Rel.getTargetId()), self.wsinc)  
            CoverArtist = Cover.getArtist()
            Covers.append([Cover.getTitle(), CoverArtist.getName(), realId(CoverArtist.getId())])

        for Cover in Covers:

            Output.append("<b>%s</b> by <b>%s</b>" % (Cover[0], getEntityLink(Cover[1],Cover[2],"artist")))

        self.html += "...is a cover of %s<br/>" % (", ".join(Output))
        return True

    def append_ar_instrument(self, Relations):

        for Rel in Relations:

            attr = Rel.getAttributes()
            artist = Rel.getTarget()

            if len(attr) == 1:

                    pre, sep, instrument = Rel.getAttributes()[0].partition("#")
                    self.html += "...has <b>%s</b> performed by <b>%s</b><br/>" % (instrument, getEntityLink(artist.getName(),realId(artist.getId()),"artist")) 
                    self.Entities.append(realId(artist.getId()))

            elif len(attr) == 2:

                    pre, sep, adjective = Rel.getAttributes()[0].partition("#")
                    pre, sep, instrument = Rel.getAttributes()[1].partition("#")
                    self.html += "...has <b>%s %s</b> performed by <b>%s</b><br/>" % (adjective.lower(), instrument, getEntityLink(artist.getName(),realId(artist.getId()),"artist")) 
                    self.Entities.append(realId(artist.getId()))

            elif len(attr) == 3:
    
                    pre, sep, adjective2 = Rel.getAttributes()[0].partition("#")
                    pre, sep, adjective1 = Rel.getAttributes()[1].partition("#")
                    pre, sep, instrument = Rel.getAttributes()[2].partition("#")
                    self.html += "...has <b>%s %s %s</b> performed by <b>%s</b><br/>" % (adjective1.lower(), adjective2.lower(), instrument, getEntityLink(artist.getName(),realId(artist.getId()),"artist")) 
                    self.Entities.append(realId(artist.getId()))

        return True

    def append_ar_samplesmaterial(self, Relations):

        Sampled = []
        Output = []

        for Rel in Relations:

            Track = self.query.getTrackById(realId(Rel.getTargetId()), self.wsinc)

            SampledArtist = Track.getArtist()
            self.Entities.append(realId(SampledArtist.getId()))
            Sampled.append([Track.getTitle(), SampledArtist.getName(), realId(SampledArtist.getId())])

        for Sample in Sampled:

            Output.append("<b>%s</b> by <b>%s</b>" % (Sample[0], getEntityLink(Sample[1],Sample[2],"artist")))

        self.html += "...contains samples from %s<br/>" % (", ".join(Output))
        return True

    def append_ar_singleperson(self, Relations, text):

        Entities = []
        Output = []

        for Rel in Relations:

            self.Entities.append(realId(Rel.getTargetId()))
            Entity = Rel.getTarget() 
            Entities.append([Entity.getName(),realId(Entity.getId())])

        for Entity in Entities:

            Output.append("<b>"+getEntityLink(Entity[0],Entity[1],"artist")+"</b>")

        self.html += "...%s %s<br/>" % (text, ", ".join(Output))
        return True

class TrackInfo:

    def __init__(self, xml, mpx):

        self.mpx = mpx

        self.query = ws.Query(musicbrainz2.webservice.WebService("www.uk.musicbrainz.org"))
        self.wsinc = musicbrainz2.webservice.TrackIncludes(trackRelations=True,artist=True,puids=True,releases=True,artistRelations=True,releaseRelations=True,urlRelations=True)
        self.wsinc_release = musicbrainz2.webservice.ReleaseIncludes(releaseEvents=True,releaseRelations=True,urlRelations=True)

        self.notebook = xml.get_widget("notebook")
        self.alignment = xml.get_widget("alignment")
        self.progress = xml.get_widget("progress")

        self.browser = WebBrowser()
        self.webview = self.browser.get_webview()
        self.webview.connect("navigation-requested", self.on_webkit_navigation_requested)

        self.alignment.add_with_viewport(self.browser.get_gui())

        self.throb = xml.get_widget("throbber")
        self.throb.set_from_file("@DATA_DIR@" + "/images/throbber.gif")
        self.notebook.set_current_page(0)

        self.artist_cached = {}

    def run(self,track):

        self.cached_html = None
        self.track = track
        self.webview.open("mpx-info:///?type=track")

    def display_track(self, track):

        if self.cached_html:
            self.webview.load_html_string(self.cached_html, "") 
        else:
            self.notebook.set_current_page(1)
            t = TrackInfoQuery (track, self.query, self.wsinc, self.wsinc_release)
            t.start()

            while not t.is_done().isSet():
                while gtk.events_pending():
                    gtk.main_iteration()

            t.stop()

            self.cached_html = t.get_html()
            self.webview.load_html_string(t.get_html(), "") 
            self.notebook.set_current_page(0)

        # In case we get called by g_idle
        return False

    def display_artist(self, mydict):

        if mydict["id"] in self.artist_cached:
            self.webview.load_html_string(self.artist_cached[mydict["id"]], "") 
        else:
            self.notebook.set_current_page(1)
            t = ArtistInfoQuery (mydict["id"], mydict["name"], self.query, self.wsinc, self.wsinc_release)
            t.start()

            while not t.is_done():
                while gtk.events_pending():
                    gtk.main_iteration()

            t.stop()
            self.artist_cached[mydict["id"]] = t.get_html()
            self.webview.load_html_string(t.get_html(), "") 
            self.notebook.set_current_page(0)

        # In case we get called by g_idle
        return False

    def clear(self):
    
        self.cached_html = None
        self.webview.load_html_string("","")
        self.notebook.set_current_page(0)

    def uriParse(self, uri):

        mydict = {}

        try:
                pre, sep, post = uri.partition("?")        
                segments = string.split(post,"&") 
             
                for segment in segments:

                    splitsegment = string.split(segment,"=")
                    mydict[splitsegment[0]] = splitsegment[1]
        except:
                pre, sep, post = uri.partition("?")        
                splitsegment = string.split(post,"=")
                mydict[splitsegment[0]] = splitsegment[1]

        return mydict

    def openUri(self, uri):

        print "TRACKINFO-WEBKIT: OPENING: " + uri
    
        if uri == "about:blank":
                uri = "mpx-info:///?type=track"

        self.browser.get_entry().props.text = uri
        self.current_uri = uri
    
        mydict = self.uriParse(uri) 

        try:
                if mydict["type"] == "artist":
           
                        self.display_artist( mydict )
                        return

                if mydict["type"] == "track":
               
                        self.display_track( self.track ) 
                        return
        except:
                print "TRACKINFO-WEBKIT: openUri exception" 

    def on_webkit_navigation_requested(self, webview, webframe, request):
    
        self.current_uri = request.get_uri()
        self.openUri(self.current_uri)
        return webkit.NAVIGATION_RESPONSE_ACCEPT


class TrackInfoDispatcher(mpx.Plugin):

    """The Trackinfo Plugin provides a Last.fm/Musicbrainz based track info for the currently played track."""

    def __init__(self,id,player,mcs):
    
        self.id = id
        self.player = player
        self.xml = gtk.glade.XML("@DATA_DIR@" + "/python-plugins/trackinfo-webkit/trackinfo-webkit.glade")
        self.vbox = self.xml.get_widget("vbox")
        self.vbox.unparent()

    def activate(self):

        self.player_infoarea_click_id = self.player.gobj().connect("metadata-updated", self.metadata_updated)
        self.player_playstatus_changed_id = self.player.gobj().connect("play-status-changed", self.pstate_changed)
        self.info = TrackInfo(self.xml,self.player)
        self.player.add_info_widget(self.vbox, "Track Info")
        return True

    def deactivate(self):
        self.player.remove_info_widget(self.vbox)
        self.player.gobj().disconnect(self.player_infoarea_click_id)
        self.player.gobj().disconnect(self.player_playstatus_changed_id)
        self.info = None

    def pstate_changed(self, blah, state):

        if self.player.get_status() == mpx.PlayStatus.STOPPED:
            self.info.clear()

    def metadata_updated(self, blah):

        print "running: trackinfo"
        self.info.run(self.player.get_metadata())

