#@
# -*- coding: utf-8 -*-
# -*- mode:python ; tab-width:4 -*- ex:set tabstop=4 shiftwidth=4 expandtab: -*-
#
# MPX Trackinfo
# (C) 2008 M. Derezynski
#

import mpx
import gtkmm
import time
import pygtk
pygtk.require('2.0')
import gtk
import gobject
import gtk.glade
import urllib
import random
import threading
from mpxapi import lastfm
from gettext import gettext as _
#import musicbrainz2
#import musicbrainz2.webservice as ws

def extract_ids(rv, v):

    for val in rv:
        v.append(val["id"].get_int())

def extract_ids_n(rv, v, n):

    for n in range(0, n):
        v.append(rv[n]["id"].get_int())

ui_playlist_popup = """ 
        <ui>
        <menubar name='musiclib-playlist-popup-playlist-list'>
           <menu action='dummy' name='musiclib-playlist-menu-playlist-list'>
               <placeholder name='musiclib-playlist-placeholder-playlist'>
               <menuitem action='mpxdj-enable'/>
               <menu action='mpxdj-playmode'>
                    <menuitem action='mpxdj-mode-analyzer'/>
                    <menuitem action='mpxdj-mode-entertain'/>
                    <menuitem action='mpxdj-mode-toptunes'/>
                    <menuitem action='mpxdj-mode-random'/>
                    <menuitem action='mpxdj-mode-memorylane'/>
                    <menuitem action='mpxdj-mode-soundsof'/>
                    <menuitem action='mpxdj-mode-gems'/>
                    <menuitem action='mpxdj-mode-dejavu'/>
                    <menuitem action='mpxdj-mode-lastfmtag'/>
               </menu>
               </placeholder>
           </menu>
        </menubar>
        </ui>
"""

class BaseMODEL__():

    def __init__(self):
        pass

class MODEL_List(BaseMODEL__):

    def __init__(self, l):

        BaseMODEL__.__init__(self)
        self.l = l

    def __getitem__(self, index):

        return self.l[index]

    def __len__(self):

        return len(self.l)

class MODEL_TreeModel(BaseMODEL__):

    def __init__(self, m):

        BaseMODEL__.__init__(self)
        self.m = m

    def __getitem__(self, index):

        return mpx.unwrap_boxed_mpxtrack(self.m[index][9])

    def __len__(self):

        return len(self.m)

class BaseOPTION__(threading.Thread):

    def __init__(self, lib, v, xml, mlib, mcs, model):

        threading.Thread.__init__(self)
        self.lib = lib
        self.xml = xml
        self.mlib = mlib
        self.v = v
        self.mcs = mcs
        self.finished = threading.Event()
        self.model = model

    def stop(self):

        self.finished.set()
        self.join()
    
    def is_done(self):

        return self.finished.isSet()

class OPTION__Analyzer(BaseOPTION__):    

    def __init__(self, lib, v, xml, mlib, mcs, model):

        BaseOPTION__.__init__(self, lib, v, xml, mlib, mcs, model)
        self.range = xml.get_widget("analyzer-range")

    def get_similartracks(self, mpxtrack):

        m = lastfm.SimilarTracks(mpxtrack[mpx.AttributeId.ARTIST].get(), mpxtrack[mpx.AttributeId.TITLE].get())
        t = m.get()
        return t

    def count_previous_mbid_presence(self, mbid):

        count = 0
        items = 0

        if (len(self.model)-1) < items:

                items = len(self.model)-1

        for i in range(0,items):

                track = self.model[len(self.model)-items+i]
                mbid_track = track[mpx.AttributeId.MB_ARTIST_ID].get()
                if mbid_track == mbid: 
                        count = count +1

        return count

    def count_previous_artist_presence(self, artist):

        count = 0
        items = 9

        if (len(self.model)-1) < items:

                items = len(self.model)-1

        for i in range(0,items):

                track = self.model[len(self.model)-items+i]
                artist_track = track[mpx.AttributeId.ARTIST].get()
                if artist_track == artist: 
                        count = count +1

        return count

    def run_similar_track(self):

        if not len(self.model):
            return

        tracks = self.get_similartracks(self.model[len(self.model)-1])[:(int(self.range.get_value())*2)]
          
        random.shuffle(tracks)

        for track in tracks: 

                rv = mpx.SQLRowV()

                if self.count_previous_artist_presence(track.getArtist().getName()) < 1:

                        self.lib.getSQL(rv, str("SELECT id FROM track_view WHERE artist ='%s' AND title = '%s' ORDER BY random() LIMIT 1" % ( track.getArtist().getName().replace("'", "''") , track.getName().replace("'","''") ) ))
                        extract_ids(rv, self.v)

                        if len(self.v) > 0:

                                return

    def run_accumulate_tags(self):

        if not len(self.model):
            return

        tags = {} 
        items = 10 

        if len(self.model) < items:
            items = len(self.model)

        for i in range(len(self.model)-items,len(self.model)-1):

            track = self.model[i]
            t = lastfm.TrackTopTags(track[mpx.AttributeId.ARTIST].get(), track[mpx.AttributeId.TITLE].get())
            ttags = t.get()
           
            for tag in ttags: 
               
                name = tag.getName()

                try: 
                        if name in tags:
                            tags[name] = tags[name] + (float(tag.getCount()) / float(len(ttags)))
                        else:
                            tags[name] = float(tag.getCount()) / float(len(ttags))
                except Exception, e:

                        print "Exception in ttags iteration: " + str(e)

        highest_count = 0
        highest_tag   = None

        for tag in tags: 

            if tags[tag] > highest_count:

                highest_tag     = tag 
                highest_count   = tags[tag]

        if highest_tag:
                    
                r = lastfm.TagTopArtists(str(highest_tag))
                a = r.get()

                random.shuffle(a)

                for artist in a: 

                    id = artist.getMBID() 
                    rv = mpx.SQLRowV()

                    if self.count_previous_mbid_presence(id) < 1:
                        self.lib.getSQL(rv, str("SELECT id FROM track_view WHERE mb_artist_id ='%s' ORDER BY random() LIMIT 1" % id))
                        extract_ids(rv, self.v)

                    if len(rv) > 0: return


    def run_similar_artist(self):

        if not len(self.model): return

        track = self.model[len(self.model)-1]

        artist = track[mpx.AttributeId.ARTIST].get()

        rv = mpx.SQLRowV()

        try:
                tries  = int(self.range.get_value())
                max    = tries

                m = lastfm.SimilarArtists(artist)
                a = m.get()[:tries]

                random.shuffle(a)

                while tries > 0:

                        name = str(a[max-tries].getName())

                        if self.count_previous_artist_presence(name) < 1:

                                self.lib.getSQL(rv, str("SELECT id FROM track_view WHERE artist ='%s' ORDER BY random() LIMIT 1" % name.replace("'","''") ))
                                extract_ids(rv, self.v)
                                if len(self.v): return

                        tries = tries - 1

        except Exception, e:
                print "Error running run_similar_artist: " + str(e) 

    def run_markov(self, lib, v):
        
        track = self.model[len(self.model)-1]
        id = track[mpx.AttributeId.MPX_TRACK_ID].get()
        markov_id = lib.markovGetRandomProbableTrack(id)
        if markov_id and markov_id != 0:
            v.append(markov_id)

    def run(self):

        callables = [self.run_accumulate_tags, self.run_similar_track, self.run_similar_artist]

        if not len(self.model):
            self.finished.set()
            return

        # I know this is really lazy, i should just create a list of indexes instead and call the subroutines in sequence
        for n in range(0,5):

                choice = random.randint(0,2)
                callables[choice]()

                if len(self.v):
                    self.finished.set()
                    return

        if not len(self.v) and id:
            self.run_markov(self.lib, self.v)

        self.finished.set()

class OPTION__LastFmTag(BaseOPTION__):    

    def __init__(self, lib, v, xml, mlib, mcs, model):

         BaseOPTION__.__init__(self, lib, v, xml, mlib, mcs, model)

    def run(self):
        
        text = self.xml.get_widget("entry-lastfm-tag").get_text()
        rv = mpx.SQLRowV()

        r = lastfm.TagTopArtists(text)
        a = r.get()
        random.shuffle(a)

        idx = 0

        while not len(rv):

                r = lastfm.SimilarArtists(a[idx].getName())
                s = r.get()

                random.shuffle(s)
                self.lib.getSQL(rv, str("SELECT id FROM track_view WHERE mb_artist_id ='%s' ORDER BY random() LIMIT 1" % a[0].getMBID()))

                l = 10
                if len(s) < 10: l = len(s)
                   
                for x in range(l):
                    self.lib.getSQL(rv, str("SELECT id FROM track_view WHERE mb_artist_id ='%s' ORDER BY random() LIMIT 1" % s[x].getMBID()))

                extract_ids(rv, self.v)
                idx = idx + 1

        self.finished.set()

class OPTION__RandomMix(BaseOPTION__):

    def __init__(self, lib, v, xml, mlib, mcs, model):

        BaseOPTION__.__init__(self, lib, v, xml, mlib, mcs, model)

    def run(self):

        if len(self.model):
            self.RANDOM_markov(self.lib, self.v)

        if not len(self.v):
            [self.RANDOM_genre,
             self.RANDOM_toptune,
            ][ random.randint(0,1) ](self.lib, self.v)
    
        self.finished.set()

    def RANDOM_genre(self, lib, v):

        choice = random.randint(0,1)

        rv = mpx.SQLRowV()

        if not len(self.model):

            lib.getSQL(rv, "SELECT id, genre FROM track_view WHERE genre IS NOT NULL ORDER BY random() LIMIT 1")
            genre = rv[0]["genre"].get_string()
            lib.getSQL(rv, "SELECT id FROM track_view WHERE genre ='%s' ORDER BY random() LIMIT 2" % genre)

        elif choice == 0: 

            track = self.model[len(self.model)-1]
            genre = track[mpx.AttributeId.GENRE].get()
            lib.getSQL(rv, "SELECT id FROM track_view WHERE genre ='%s' ORDER BY random() LIMIT 2" % genre)
        
        elif choice == 1:

            lib.getSQL(rv, "SELECT id FROM track_view ORDER BY random() LIMIT 2")

        extract_ids(rv, v)

    def RANDOM_toptune(self, lib, v):
    
        rv = mpx.SQLRowV()
        self.lib.getSQL(rv, "SELECT id FROM track_view WHERE rating > 3 AND album_rating > 3 ORDER BY random() LIMIT 1")
        extract_ids(rv, v)

    def RANDOM_markov(self, lib, v):
        
        track = self.model[len(self.model)-1]
        id = track[mpx.AttributeId.MPX_TRACK_ID].get()
        markov_id = lib.markovGetRandomProbableTrack(id)
        if markov_id and markov_id != 0:
            v.append(markov_id)

class OPTION__TopTunes(BaseOPTION__):

    def __init__(self, lib, v, xml, mlib, mcs, model):

        BaseOPTION__.__init__(self, lib, v, xml, mlib, mcs, model)

    def run(self):
    
        rv = mpx.SQLRowV()
        self.lib.getSQL(rv, "SELECT id FROM track_view WHERE rating > 3 AND album_rating > 3 ORDER BY random() LIMIT 10")
        extract_ids(rv, self.v)
        self.finished.set()

class OPTION__PlayAll(BaseOPTION__):

    def __init__(self, lib, v, xml, mlib, mcs, model):

        BaseOPTION__.__init__(self, lib, v, xml, mlib, mcs, model)

    def run(self):

        rv = mpx.SQLRowV()
        self.lib.getSQL(rv, "SELECT id FROM track_view ORDER BY album_j, track")
        extract_ids(rv, self.v)
        self.finished.set()

class OPTION__EntertainMe(BaseOPTION__):

    def __init__(self, lib, v, xml, mlib, mcs, model):

        BaseOPTION__.__init__(self, lib, v, xml, mlib, mcs, model)

    def run(self):

        [self.ENTERTAIN_Local,
         self.ENTERTAIN_LastFm
        ][random.randint(0,1)]()

        self.finished.set()

    def ENTERTAIN_Local(self):

        rv = mpx.SQLRowV()
        self.lib.getSQL(rv, "SELECT id FROM track_view WHERE pcount > 20")
        random.shuffle(rv)
        extract_ids(rv[0:1], self.v)
  
    def ENTERTAIN_LastFm(self):

        r = lastfm.UserTopTracks(self.mcs.key_get_string("lastfm","username"))
        t = r.get()
        random.shuffle(t)
        rv = mpx.SQLRowV()
        artist = t[0].getArtist().replace("'","''")
        title = t[0].getName().replace("'","''")
        self.lib.getSQL(rv, str("SELECT id FROM track_view WHERE artist = '%s' AND title = '%s' LIMIT 1" % (artist,title)))
        extract_ids(rv, self.v)

class OPTION__SoundsOf(BaseOPTION__):

    def __init__(self, lib, v, xml, mlib, mcs, model):

        BaseOPTION__.__init__(self, lib, v, xml, mlib, mcs, model)
 
    def run(self):
    
        active = self.xml.get_widget("cbox-decade").get_active()
        upper = 0
        lower = 0

        if(active == 6):
            lower = 2000
            upper = 3000
        else:
            lower = 1940 + (active * 10)
            upper = 1950 + (active * 10)
        
        rv = mpx.SQLRowV()
        for x in range(10):
            self.lib.getSQL(rv, "SELECT id FROM track_view WHERE date >= " + str(lower) + " AND date < " + str(upper) + " ORDER BY random() LIMIT 1")

        extract_ids(rv, self.v)
        self.finished.set()

class OPTION__ForgottenGems(BaseOPTION__):

    def __init__(self, lib, v, xml, mlib, mcs, model):

        BaseOPTION__.__init__(self, lib, v, xml, mlib, mcs, model)
 
    def run(self):
   
        rv = mpx.SQLRowV() 
        self.lib.getSQL(rv, "SELECT id FROM track_view WHERE pdate IS NOT NULL AND pcount > 3 ORDER BY pdate ASC")
        random.shuffle(rv)
        extract_ids_n(rv, self.v, 5)
        self.finished.set()

class OPTION__DejaVu(BaseOPTION__):

    def __init__(self, lib, v, xml, mlib, mcs, model):

        BaseOPTION__.__init__(self, lib, v, xml, mlib, mcs, model)
 
    def run(self):
   
        rv = mpx.SQLRowV() 
        self.lib.getSQL(rv, "SELECT id FROM track_view ORDER BY pcount DESC LIMIT 10")
        random.shuffle(rv)
        extract_ids_n(rv, self.v, 5)
        self.finished.set()

class MPXDJ(mpx.Plugin):

    """MPXDJ DJs your music library for you!"""

    def __init__(self,id,player,mcs):
       
        self.id = id 
        self.lib = player.get_library()
        self.covers = player.get_covers()
        self.mlib = player.get_source("36068e19-dfb3-49cd-85b4-52cea16fe0fd"); 
        self.mcs = mcs
        self.player = player
        self.actiongroup = gtk.ActionGroup("Actions-MPXDJ")
        self.ui = self.player.ui()
        self.playmode = 0

        self.xml = gtk.glade.XML("@DATA_DIR@" + "/python-plugins/mpxdj/mpxdj.glade")
        self.widget = self.xml.get_widget("widget")
        self.widget.unparent()

        self.combo = self.xml.get_widget("combobox")
        self.label = self.xml.get_widget("label")

        self.go = self.xml.get_widget("button-go")
        self.go.set_sensitive(False)
        self.go.connect("clicked", self.on_button_go)

        self.header_image = self.xml.get_widget("header-image")
        self.header_image.set_from_file("@DATA_DIR@" + "/python-plugins/mpxdj/mpxdj.png")

        self.notebook = self.xml.get_widget("notebook")

        self.working = False

        try:
            self.icon = gtk.gdk.pixbuf_new_from_file("@DATA_DIR@" + "/python-plugins/mpxdj/mpxdj-icon.png")
        except:
            self.icon = None

            
        self.callables = [
            OPTION__Analyzer,
            OPTION__EntertainMe, 
            OPTION__TopTunes, 
            OPTION__RandomMix, 
            None,
            OPTION__SoundsOf, 
            OPTION__ForgottenGems,
            OPTION__DejaVu,
            OPTION__LastFmTag 
        ]

        self.gooneshot = [
            False,
            True,
            True,
            True,
            False,
            True,
            True,
            True,
            True
       ] 

        self.helptexts = [
            "Analyzes the playlist and plays similar Music",
            "Creates a running order composed of the most frequently played tracks.",
            "Plays some of the best rated tracks",
            "Plays random, but similar tracks",
            "",
            "Plays tracks from a specific decade.",
            "Plays long forgotten but popular tracks.",
            "Plays a set number of the most frequently played tracks.",
            "Creates a playlist from your music library based on a Last.fm tag"
        ]   

        self.actionnames = [
            "mpxdj-mode-analyzer",
            "mpxdj-mode-entertain",
            "mpxdj-mode-toptunes",
            "mpxdj-mode-random",
            "mpxdj-mode-memorylane",
            "mpxdj-mode-soundsof",
            "mpxdj-mode-gems",
            "mpxdj-mode-dejavu",
            "mpxdj-mode-lastfmtag",
        ] 

        self.options = [
            "Analyzer",
            "Entertain Me!",
            "Top Tunes",
            "Random Mix",
            "Memory Lane",
            "Sounds Of...",
            "Forgotten Gems",
            "Deja Vu",
            "Last.fm Tag"
        ]

        self.action1 = gtk.ToggleAction('mpxdj-enable', "Enable MPXDJ", "", "")
        self.action2 = gtk.Action('mpxdj-playmode', "MPXDJ Play Mode", "", "")
        
        self.actiongroup.add_action(self.action1)
        self.actiongroup.add_action(self.action2)

        self.action_handler1 = self.action1.connect("toggled", self.on_enable_toggled)

        self.action = []
        idx = 0

        for action in self.actionnames:

                a = gtk.RadioAction(self.actionnames[idx], self.options[idx], "", "", idx)
                if not self.callables[idx]: a.set_sensitive(False)
                self.action.append(a)
                if idx is not 0: a.set_group(self.action[0])
                self.actiongroup.add_action(a)
                idx = idx + 1

        self.action_handler2 = self.action[0].connect("changed", self.on_mode_changed)
        self.action[0].set_active(True)

        self.ui.insert_action_group(self.actiongroup, pos=-1)
        self.ui.add_ui_from_string(ui_playlist_popup)

        cell = gtk.CellRendererText()
        self.combo.pack_start(cell)
        self.combo.add_attribute(cell, "text", 0)

        self.store = gtk.ListStore(gobject.TYPE_STRING)
        for option in self.options: self.store.append([option])

        self.combo.connect("changed", self.on_mode_cbox_changed)
        self.combo.set_model(self.store)
        self.combo.set_active(0)

        self.working = False

    def on_mode_changed(self, action, current):

        self.combo.set_active(current.get_current_value())
        self.playmode = current.get_current_value()
        self.player.show_plugin(self.id)

    def on_enable_toggled(self, action):

        if action.get_active():

            self.player.activate_plugin(self.id)

            model = self.mlib.get_playlist_model()
            path  = self.mlib.get_playlist_current_path()

            if (not path) or (not len(model)) or ((len(model)-1) == path[0]):

                if (not path) or (not len(model)) and self.gooneshot[self.combo.get_active()]:
                    self.on_button_go([])
                else:
                    self.on_playlist_end([],[])

        else:
            self.player.deactivate_plugin(self.id)

    def get_icon(self):

        return self.icon

    def get_gui(self):

        return self.widget

    def activate(self):

        self.conn_playlist_end = self.mlib.gobj().connect("playlist-end", self.on_playlist_end)
        self.action1.handler_block(self.action_handler1)
        self.action1.set_active(True) 
        self.action1.handler_unblock(self.action_handler1)

    def deactivate(self):

        self.mlib.gobj().disconnect(self.conn_playlist_end)
        self.action1.handler_block(self.action_handler1)
        self.action1.set_active(False) 
        self.action1.handler_unblock(self.action_handler1)

    def on_mode_cbox_changed(self, cbox):

        self.label.set_text(self.helptexts[cbox.get_active()])      
        self.notebook.set_current_page(cbox.get_active())       

        if not self.working:
            self.go.set_sensitive(self.gooneshot[self.combo.get_active()] is not False)

        self.action[0].handler_block(self.action_handler2)
        self.action[self.combo.get_active()].set_active(True) 
        self.action[0].handler_unblock(self.action_handler2)

        self.playmode = self.combo.get_active() 

    def on_playlist_end(self, object, empty):

        if self.working: return

        self.working = True
        self.go.set_sensitive(False)
        self.go.set_label("Working...")
        self.mlib.set_sensitive(False)

        idv = mpx.IdVector()
        klass = self.callables[self.playmode]

        if klass:

            instance = klass(self.lib, idv, self.xml, self.mlib, self.mcs, MODEL_TreeModel(self.mlib.get_playlist_model()))
            instance.start () 
        
            while not instance.is_done():
                while gtk.events_pending():
                    gtk.main_iteration()

            instance.stop ()

            if len(idv):
                self.mlib.play_tracks(idv, False) 
            else:
                self.player.push_message(_("Unable to Create New Track!"))

        self.go.set_label("Go One-Shot!")
        self.go.set_sensitive(self.gooneshot[self.combo.get_active()] is not False)
        self.mlib.set_sensitive(True)
        self.working = False

    def on_button_go(self, object):

        if self.working: return

        self.working = True
        self.go.set_sensitive(False)
        self.go.set_label("Working...")
        self.mlib.set_sensitive(False)

        idv = mpx.IdVector()
        klass = self.callables[self.combo.get_active()]

        if klass:

            instance = klass(self.lib, idv, self.xml, self.mlib, self.mcs, MODEL_TreeModel(self.mlib.get_playlist_model()))
            instance.start () 
       
            while not instance.is_done():
                while gtk.events_pending():
                    gtk.main_iteration()

            instance.stop ()

            if len(idv):
                self.mlib.play_tracks(idv, True)
            else:
                self.player.push_message(_("Unable to Create New Track!"))

        self.go.set_label("Go One-Shot!")
        self.go.set_sensitive(self.gooneshot[self.combo.get_active()] is not False)
        self.mlib.set_sensitive(True)
        self.working = False
