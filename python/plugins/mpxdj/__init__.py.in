#@
# -*- coding: utf-8 -*-
# -*- mode:python ; tab-width:4 -*- ex:set tabstop=4 shiftwidth=4 expandtab: -*-
#
# MPX Trackinfo
# (C) 2008 M. Derezynski
#

import mpx
import gtkmm
import time
import pygtk
pygtk.require('2.0')
import gtk
import gobject
import gtk.glade
import urllib
import random
import threading
from mpxapi import lastfm
from gettext import gettext as _
#import musicbrainz2
#import musicbrainz2.webservice as ws

def extract_ids(rv, v):

    for val in rv:
        v.append(val["id"].get_int())

def extract_ids_n(rv, v, n):

    for n in range(0, n):
        v.append(rv[n]["id"].get_int())

ui_playlist_popup = """ 
        <ui>
        <menubar name='musiclib-playlist-popup-playlist-list'>
           <menu action='dummy' name='musiclib-playlist-menu-playlist-list'>
               <placeholder name='musiclib-playlist-placeholder-playlist'>
               <menuitem action='mpxdj-enable'/>
               <menu action='mpxdj-playmode'>
                    <menuitem action='mpxdj-mode-analyzer'/>
                    <menuitem action='mpxdj-mode-entertain'/>
                    <menuitem action='mpxdj-mode-toptunes'/>
                    <menuitem action='mpxdj-mode-random'/>
                    <menuitem action='mpxdj-mode-memorylane'/>
                    <menuitem action='mpxdj-mode-soundsof'/>
                    <menuitem action='mpxdj-mode-gems'/>
                    <menuitem action='mpxdj-mode-dejavu'/>
                    <menuitem action='mpxdj-mode-lastfmtag'/>
               </menu>
               </placeholder>
           </menu>
        </menubar>
        </ui>
"""


class BaseOPTION__(threading.Thread):

    def __init__(self, lib, v, xml, mlib, mcs):

        threading.Thread.__init__(self)
        self.lib = lib
        self.xml = xml
        self.mlib = mlib
        self.v = v
        self.mcs = mcs
        self.finished = threading.Event()

    def stop(self):

        self.finished.set()
        self.join()
    
    def is_done(self):

        return self.finished.isSet()

class OPTION__Analyzer(BaseOPTION__):    

    def __init__(self, lib, v, xml, mlib, mcs):

         BaseOPTION__.__init__(self, lib, v, xml, mlib, mcs)

    def get_similartracks(self, mpxtrack):

        m = lastfm.SimilarTracks(mpxtrack[mpx.AttributeId.ARTIST].get(), mpxtrack[mpx.AttributeId.TITLE].get())
        t = m.get()
        return t

    def count_previous_mbid_presence(self, playlist, mbid):

        count = 0
        items = 0

        if (len(playlist)-1) < items:

                items = len(playlist)-1

        for i in range(0,items):

                track = mpx.unwrap_boxed_mpxtrack(playlist[len(playlist)-items+i][9])
                mbid_track = track[mpx.AttributeId.MB_ARTIST_ID].get()
                if mbid_track == mbid: 
                        count = count +1

        return count

    def count_previous_artist_presence(self, playlist, artist):

        count = 0
        items = 9

        if (len(playlist)-1) < items:

                items = len(playlist)-1

        for i in range(0,items):

                track = mpx.unwrap_boxed_mpxtrack(playlist[len(playlist)-items+i][9])
                artist_track = track[mpx.AttributeId.ARTIST].get()
                if artist_track == artist: 
                        count = count +1

        return count

    def run_similar_track(self):

        playlist = self.mlib.get_playlist_model()
        if not len(playlist): return

        tracks = self.get_similartracks(mpx.unwrap_boxed_mpxtrack(playlist[len(playlist)-1][9]))
          
        random.shuffle(tracks)

        for track in tracks: 

                rv = mpx.SQLRowV()

                if self.count_previous_artist_presence(playlist, track.getArtist().getName()) <= 1:

                        self.lib.getSQL(rv, str("SELECT id FROM track_view WHERE artist ='%s' AND title = '%s' ORDER BY random() LIMIT 1" % ( track.getArtist().getName().replace("'", "''") , track.getName().replace("'","''") ) ))
                        extract_ids(rv, self.v)

                        if len(self.v) > 0:

                                return

    def run_accumulate_tags(self):

        playlist = self.mlib.get_playlist_model()
        if not len(playlist): return

        tags = {} 
        items = 10 

        if len(playlist) < items:
            items = len(playlist)

        for i in range(len(playlist)-items,len(playlist)-1):

            track = mpx.unwrap_boxed_mpxtrack(playlist[i][9])
            t = lastfm.TrackTopTags(track[mpx.AttributeId.ARTIST].get(), track[mpx.AttributeId.TITLE].get())
            ttags = t.get()
           
            for tag in ttags: 
               
                name = tag.getName()

                try: 
                        if name in tags:
                            tags[name] = tags[name] + (float(tag.getCount()) / float(len(ttags)))
                        else:
                            tags[name] = float(tag.getCount()) / float(len(ttags))
                except Exception, e:

                        print "Exception in ttags iteration: " + str(e)

        highest_count = 0
        highest_tag   = None

        for tag in tags: 

            if tags[tag] > highest_count:

                highest_tag     = tag 
                highest_count   = tags[tag]

        if highest_tag:
                    
                r = lastfm.TagTopArtists(str(highest_tag))
                a = r.get()

                random.shuffle(a)

                for artist in a: 

                    id = artist.getMBID() 
                    rv = mpx.SQLRowV()

                    if self.count_previous_mbid_presence(playlist, id) <= 1:
                        self.lib.getSQL(rv, str("SELECT id FROM track_view WHERE mb_artist_id ='%s' ORDER BY random() LIMIT 1" % id))
                        extract_ids(rv, self.v)

                    if len(rv) > 0: return


    def run_similar_artist(self):

        playlist = self.mlib.get_playlist_model()
        if not len(playlist): return

        track = mpx.unwrap_boxed_mpxtrack(playlist[len(playlist)-1][9])
        artist = track[mpx.AttributeId.ARTIST].get()
        rv = mpx.SQLRowV()

        try:
                m = lastfm.SimilarArtists(artist)
                a = m.get()

                random.shuffle(a)

                tries = 3

                while tries > 0:

                        name = str(a[3-tries].getName())

                        if self.count_previous_artist_presence(playlist, name) <= 1:

                                self.lib.getSQL(rv, str("SELECT id FROM track_view WHERE artist ='%s' ORDER BY random() LIMIT 1" % name.replace("'","''") ))
                                extract_ids(rv, self.v)
                                if len(self.v): return

                        tries = tries - 1

        except Exception, e:
                print "Error running run_similar_artist: " + str(e) 

    def run_markov(self):

        # Find a track based on Markov

        playlist  = self.mlib.get_playlist_model()
        track_id  = playlist[len(playlist)-1][7] 
        markov_id = self.lib.markovGetRandomProbableTrack(track_id)

        self.v.append(markov_id)

    def run(self):

        playlist = self.mlib.get_playlist_model()
        callables = [self.run_accumulate_tags, self.run_similar_track, self.run_similar_artist]

        if not len(playlist):
            self.finished.set()
            return

        tries = 5

        while tries:

                choice = random.randint(0,2)

                callables[choice]()
                if len(self.v):
                    self.finished.set()
                    return

                tries -= 1

        self.finished.set()

class OPTION__LastFmTag(BaseOPTION__):    

    def __init__(self, lib, v, xml, mlib, mcs):

         BaseOPTION__.__init__(self, lib, v, xml, mlib, mcs)

    def run(self):
        
        text = self.xml.get_widget("entry-lastfm-tag").get_text()
        rv = mpx.SQLRowV()

        #try:
        r = lastfm.TagTopArtists(text)
        a = r.get()

        for artist in a:
            self.lib.getSQL(rv, str("SELECT id FROM track_view WHERE mb_artist_id ='%s' ORDER BY random() LIMIT 1" % artist.getMBID()))

        #except Exception, e:
        #        print e

        extract_ids(rv, self.v)
        self.finished.set()

class OPTION__RandomMix(BaseOPTION__):

    def __init__(self, lib, v, xml, mlib, mcs):

        BaseOPTION__.__init__(self, lib, v, xml, mlib, mcs)

    def run(self):

        [self.RANDOM_genre,
         self.RANDOM_toptune,
         self.RANDOM_markov
        ][ random.randint(0,2) ](self.lib, self.v)

        self.finished.set()

    def RANDOM_genre(self, lib, v):

        choice = random.randint(0,1)
        playlist = self.mlib.get_playlist_model()

        rv = mpx.SQLRowV()

        if not len(playlist):

            lib.getSQL(rv, "SELECT id, genre FROM track_view WHERE genre IS NOT NULL ORDER BY random() LIMIT 1")
            genre = rv[0]["genre"].get_string()
            lib.getSQL(rv, "SELECT id FROM track_view WHERE genre ='%s' ORDER BY random() LIMIT 2" % genre)

        elif choice == 0: 

            track = mpx.unwrap_boxed_mpxtrack(playlist[len(playlist)-1][9])
            genre = track[mpx.AttributeId.GENRE].get()
            lib.getSQL(rv, "SELECT id FROM track_view WHERE genre ='%s' ORDER BY random() LIMIT 2" % genre)
        
        elif choice == 1:

            lib.getSQL(rv, "SELECT id FROM track_view ORDER BY random() LIMIT 2")

        extract_ids(rv, v)

    def RANDOM_toptune(self, lib, v):
    
        rv = mpx.SQLRowV()
        self.lib.getSQL(rv, "SELECT id FROM track_view WHERE rating > 3 AND album_rating > 3 ORDER BY random() LIMIT 1")
        extract_ids(rv, v)

    def RANDOM_markov(self, lib, v):
        
        playlist = self.mlib.get_playlist_model()
        track = mpx.unwrap_boxed_mpxtrack(playlist[len(playlist)-1][9])
        id = track[mpx.AttributeId.MPX_TRACK_ID].get()
        markov_id = lib.markovGetRandomProbableTrack(id)
        v.append(markov_id)

class OPTION__TopTunes(BaseOPTION__):

    def __init__(self, lib, v, xml, mlib, mcs):

        BaseOPTION__.__init__(self, lib, v, xml, mlib, mcs)

    def run(self):
    
        rv = mpx.SQLRowV()
        self.lib.getSQL(rv, "SELECT id FROM track_view WHERE rating > 3 AND album_rating > 3 ORDER BY random() LIMIT 10")
        extract_ids(rv, self.v)
        self.finished.set()

class OPTION__PlayAll(BaseOPTION__):

    def __init__(self, lib, v, xml, mlib, mcs):

        BaseOPTION__.__init__(self, lib, v, xml, mlib, mcs)

    def run(self):

        rv = mpx.SQLRowV()
        self.lib.getSQL(rv, "SELECT id FROM track_view ORDER BY album_j, track")
        extract_ids(rv, self.v)
        self.finished.set()

class OPTION__EntertainMe(BaseOPTION__):

    def __init__(self, lib, v, xml, mlib, mcs):

        BaseOPTION__.__init__(self, lib, v, xml, mlib, mcs)

    def run(self):

        [self.ENTERTAIN_Local,
         self.ENTERTAIN_LastFm
        ][random.randint(0,1)]()

        self.finished.set()

    def ENTERTAIN_Local(self):

        rv = mpx.SQLRowV()
        self.lib.getSQL(rv, "SELECT id FROM track_view WHERE pcount > 20")
        random.shuffle(rv)
        extract_ids(rv[0:1], self.v)
  
    def ENTERTAIN_LastFm(self):

        r = lastfm.UserTopTracks(self.mcs.key_get_string("lastfm","username"))
        t = r.get()
        random.shuffle(t)
        rv = mpx.SQLRowV()
        artist = t[0].getArtist().replace("'","''")
        title = t[0].getName().replace("'","''")
        self.lib.getSQL(rv, str("SELECT id FROM track_view WHERE artist = '%s' AND title = '%s' LIMIT 1" % (artist,title)))
        extract_ids(rv, self.v)

class OPTION__SoundsOf(BaseOPTION__):

    def __init__(self, lib, v, xml, mlib, mcs):

        BaseOPTION__.__init__(self, lib, v, xml, mlib, mcs)
 
    def run(self):
    
        active = self.xml.get_widget("cbox-decade").get_active()
        upper = 0
        lower = 0

        if(active == 6):
            lower = 2000
            upper = 3000
        else:
            lower = 1940 + (active * 10)
            upper = 1950 + (active * 10)
        
        rv = mpx.SQLRowV()
        for x in range(10):
            self.lib.getSQL(rv, "SELECT id FROM track_view WHERE date >= " + str(lower) + " AND date < " + str(upper) + " ORDER BY random() LIMIT 1")

        extract_ids(rv, self.v)
        self.finished.set()

class MPXDJ(mpx.Plugin):

    """MPXDJ DJs your music library for you!"""

    def __init__(self,id,player,mcs):
       
        self.id = id 
        self.lib = player.get_library()
        self.covers = player.get_covers()
        self.mlib = player.get_source("36068e19-dfb3-49cd-85b4-52cea16fe0fd"); 
        self.mcs = mcs
        self.player = player
        self.actiongroup = gtk.ActionGroup("Actions-MPXDJ")
        self.ui = self.player.ui()
        self.playmode = 0

        self.xml = gtk.glade.XML("@DATA_DIR@" + "/python-plugins/mpxdj/mpxdj.glade")
        self.widget = self.xml.get_widget("widget")
        self.widget.unparent()

        self.combo = self.xml.get_widget("combobox")
        self.label = self.xml.get_widget("label")

        self.go = self.xml.get_widget("button-go")
        self.go.set_sensitive(False)
        self.go.connect("clicked", self.on_button_go)

        self.header_image = self.xml.get_widget("header-image")
        self.header_image.set_from_file("@DATA_DIR@" + "/python-plugins/mpxdj/mpxdj.png")

        self.notebook = self.xml.get_widget("notebook")


        try:
            self.icon = gtk.gdk.pixbuf_new_from_file("@DATA_DIR@" + "/python-plugins/mpxdj/mpxdj-icon.png")
        except:
            self.icon = None

            
        self.callables = [
            OPTION__Analyzer,
            OPTION__EntertainMe, 
            OPTION__TopTunes, 
            OPTION__RandomMix, 
            None,
            OPTION__SoundsOf, 
            None,
            None,
            OPTION__LastFmTag 
        ]

        self.helptexts = [
            "Analyzes the playlist and plays similar Music",
            "Creates a running order composed of the most frequently played tracks.",
            "Plays a set number of the most frequently played tracks.",
            "Plays random, but similar tracks",
            "",
            "Plays tracks from a specific decade.",
            "",
            "",
            "Creates a playlist from your music library based on a Last.fm tag"
        ]   

        self.actionnames = [
            "mpxdj-mode-analyzer",
            "mpxdj-mode-entertain",
            "mpxdj-mode-toptunes",
            "mpxdj-mode-random",
            "mpxdj-mode-memorylane",
            "mpxdj-mode-soundsof",
            "mpxdj-mode-gems",
            "mpxdj-mode-dejavu",
            "mpxdj-mode-lastfmtag",
        ] 

        self.options = [
            "Analyzer",
            "Entertain Me!",
            "Top Tunes",
            "Random Mix",
            "Memory Lane",
            "Sounds Of...",
            "Forgotten Gems",
            "Deja Vu",
            "Last.fm Tag"
        ]

        action1 = gtk.ToggleAction('mpxdj-enable', "Enable MPXDJ", "", "")
        action2 = gtk.Action('mpxdj-playmode', "MPXDJ Play Mode", "", "")
        
        self.actiongroup.add_action(action1)
        self.actiongroup.add_action(action2)

        action1.connect("toggled", self.on_enable_toggled)

        self.action = []
        idx = 0

        for action in self.actionnames:

                a = gtk.RadioAction(self.actionnames[idx], self.options[idx], "", "", idx)
                if not self.callables[idx]: a.set_sensitive(False)
                self.action.append(a)
                if idx is not 0: a.set_group(self.action[0])
                self.actiongroup.add_action(a)
                idx = idx + 1

        self.action[0].connect("changed", self.on_mode_changed)
        self.action[0].set_active(True)

        self.ui.insert_action_group(self.actiongroup, pos=-1)
        self.ui.add_ui_from_string(ui_playlist_popup)

        cell = gtk.CellRendererText()
        self.combo.pack_start(cell)
        self.combo.add_attribute(cell, "text", 0)

        self.store = gtk.ListStore(gobject.TYPE_STRING)
        for option in self.options: self.store.append([option])

        self.combo.connect("changed", self.on_mode_cbox_changed)
        self.combo.set_model(self.store)
        self.combo.set_active(0)

        self.working = False

    def on_mode_changed(self, action, current):

        self.playmode = current.get_current_value()

    def on_enable_toggled(self, action):

        if action.get_active():
            self.player.activate_plugin(self.id)
        else:
            self.player.deactivate_plugin(self.id)

    def get_icon(self):

        return self.icon

    def get_gui(self):

        return self.widget

    def activate(self):

        self.conn_playlist_end = self.mlib.gobj().connect("playlist-end", self.on_playlist_end)

    def deactivate(self):

        self.mlib.gobj().disconnect(self.conn_playlist_end)

    def on_mode_cbox_changed(self, cbox):

        self.label.set_text(self.helptexts[cbox.get_active()])      
        self.notebook.set_current_page(cbox.get_active())       
        self.go.set_sensitive(self.callables[self.combo.get_active()] is not None)

    def on_playlist_end(self, object, empty):

        if self.working: return

        self.working = True
        self.go.set_sensitive(False)
        self.go.set_label("Working...")
        self.mlib.set_sensitive(False)

        idv = mpx.IdVector()
        klass = self.callables[self.playmode]
        if klass:
            instance = klass(self.lib, idv, self.xml, self.mlib, self.mcs)
            instance.start () 
        
            while not instance.is_done():
                while gtk.events_pending():
                    gtk.main_iteration()

            instance.stop ()

            if len(idv):
                self.mlib.play_tracks(idv, False) 
            else:
                self.player.push_message(_("Failed to produce track"))

        self.go.set_label("Go! (one-shot)")
        self.go.set_sensitive(True)
        self.mlib.set_sensitive(True)
        self.working = False

    def on_button_go(self, object):

        if self.working: return

        self.working = True
        self.go.set_sensitive(False)
        self.go.set_label("Working...")
        self.mlib.set_sensitive(False)

        idv = mpx.IdVector()
        klass = self.callables[self.combo.get_active()]
        if klass:
            instance = klass(self.lib, idv, self.xml, self.mlib, self.mcs)
            instance.start () 
       
            while not instance.is_done():
                while gtk.events_pending():
                    gtk.main_iteration()

            instance.stop ()

            if len(idv):
                self.mlib.play_tracks(idv, True)
            else:
                self.player.push_message(_("Failed to produce track"))

        self.go.set_label("Go!")
        self.go.set_sensitive(True)
        self.mlib.set_sensitive(True)
        self.working = False
