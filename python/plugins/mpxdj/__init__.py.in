#
# -*- coding: utf-8 -*-
# -*- mode:python ; tab-width:4 -*- ex:set tabstop=4 shiftwidth=4 expandtab: -*-
#
# MPX Trackinfo
# (C) 2008 M. Derezynski
#

import mpx
import gtkmm
import time
import pygtk
pygtk.require('2.0')
import gtk
import gobject
import gtk.glade
import urllib
import random
import threading
from mpxapi import lastfm
#import musicbrainz2
#import musicbrainz2.webservice as ws

def extract_ids(rv, v):

    for val in rv:
        v.append(val["id"].get_int())

class BaseOption(threading.Thread):

    def __init__(self, lib, v, xml, mlib, mcs):

        threading.Thread.__init__(self)
        self.lib = lib
        self.xml = xml
        self.mlib = mlib
        self.v = v
        self.mcs = mcs
        self.finished = threading.Event()

    def stop(self):

        self.finished.set()
        self.join()
    
    def is_done(self):

        return self.finished.isSet()

class OptionAnalyzer(BaseOption):    

    def __init__(self, lib, v, xml, mlib, mcs):

         BaseOption.__init__(self, lib, v, xml, mlib, mcs)

    def get_similartracks(self, mpxtrack):

        m = lastfm.SimilarTracks(mpxtrack[mpx.AttributeId.ARTIST].get(), mpxtrack[mpx.AttributeId.TITLE].get())
        t = m.get()
        return t

    def count_previous_mbid_presence(self, playlist, mbid):

        count = 0
        items = 0

        if (len(playlist)-1) < items:

                items = len(playlist)-1

        for i in range(0,items):

                track = mpx.unwrap_boxed_mpxtrack(playlist[len(playlist)-items+i][9])
                mbid_track = track[mpx.AttributeId.MB_ARTIST_ID].get()
                if mbid_track == mbid: 
                        count = count +1

        return count

    def count_previous_artist_presence(self, playlist, artist):

        count = 0
        items = 9

        if (len(playlist)-1) < items:

                items = len(playlist)-1

        for i in range(0,items):

                track = mpx.unwrap_boxed_mpxtrack(playlist[len(playlist)-items+i][9])
                artist_track = track[mpx.AttributeId.ARTIST].get()
                if artist_track == artist: 
                        count = count +1

        return count

    def run_similar_track(self):

        playlist = self.mlib.get_playlist_model()
        if not len(playlist): return

        tracks = self.get_similartracks(mpx.unwrap_boxed_mpxtrack(playlist[len(playlist)-1][9]))
          
        random.shuffle(tracks)

        for track in tracks: 

                rv = mpx.SQLRowV()

                if self.count_previous_artist_presence(playlist, track.getArtist().getName()) <= 1:

                        self.lib.getSQL(rv, str("SELECT id FROM track_view WHERE artist ='%s' AND title = '%s' ORDER BY mpxrand() LIMIT 1" % ( track.getArtist().getName().replace("'", "''") , track.getName().replace("'","''") ) ))
                        extract_ids(rv, self.v)

                        if len(self.v) > 0:

                                return

    def run_accumulate_tags(self):

        playlist = self.mlib.get_playlist_model()
        tags = {} 
        items = 10 

        if len(playlist) < items:
            items = len(playlist)

        for i in range(len(playlist)-items,len(playlist)-1):

            track = mpx.unwrap_boxed_mpxtrack(playlist[i][9])
            t = lastfm.TrackTopTags(track[mpx.AttributeId.ARTIST].get(), track[mpx.AttributeId.TITLE].get())
            ttags = t.get()
           
            for tag in ttags: 
               
                name = tag.getName()
 
                if name in tags:
                    tags[name] = tags[name] + (float(tag.getCount()) / float(len(ttags)))
                else:
                    tags[name] = float(tag.getCount()) / float(len(ttags))

        highest_count = 0
        highest_tag   = None

        for tag in tags: 

            if tags[tag] > highest_count:

                highest_tag     = tag 
                highest_count   = tags[tag]

        if highest_tag:
                    
                r = lastfm.TagTopArtists(str(highest_tag))
                a = r.get()

                random.shuffle(a)

                for artist in a: 

                    id = artist.getMBID() 
                    rv = mpx.SQLRowV()

                    if self.count_previous_mbid_presence(playlist, id) <= 1:
                        self.lib.getSQL(rv, str("SELECT id FROM track_view WHERE mb_artist_id ='%s' ORDER BY mpxrand() LIMIT 1" % id))
                        extract_ids(rv, self.v)

                    if len(rv) > 0: return


    def run_similar_artist(self):

        rv          = mpx.SQLRowV()
        playlist    = self.mlib.get_playlist_model()
        track       = mpx.unwrap_boxed_mpxtrack(playlist[len(playlist)-1][9])
        artist      = track[mpx.AttributeId.ARTIST].get()

        try:
                m = lastfm.SimilarArtists(artist)
                a = m.get()

                random.shuffle(a)

                tries = 3

                while tries > 0:

                        name = str(a[3-tries].getName())

                        if self.count_previous_artist_presence(playlist, name) <= 1:

                                self.lib.getSQL(rv, str("SELECT id FROM track_view WHERE artist ='%s' ORDER BY mpxrand() LIMIT 1" % name.replace("'","''") ))
                                extract_ids(rv, self.v)
                                if len(self.v): return

                        tries = tries - 1

        except Exception, e:
                print "Error running run_similar_artist: " + str(e) 

    def run_markov(self):

        # Find a track based on Markov

        playlist  = self.mlib.get_playlist_model()
        track_id  = playlist[len(playlist)-1][7] 
        markov_id = self.lib.markovGetRandomProbableTrack(track_id)

        if markov_id != -1:
                self.v.append(markov_id)

    def run(self):

        playlist  = self.mlib.get_playlist_model()
        ieeev = mpx.IEEEV()

        callables = [self.run_accumulate_tags, self.run_similar_track, self.run_similar_artist]

        if len(playlist) < 3:
                ieeev.append(float(10))
                ieeev.append(float(45))
                ieeev.append(float(45))
        else:
                ieeev.append(float(40))
                ieeev.append(float(30))
                ieeev.append(float(30))

        choice = mpx.rand(ieeev)

        try:
                callables[choice]()

                if len(self.v):
                        self.finished.set()
                        return
        except Exception, e:
                print e 

        try:
                self.run_markov()
                if len(self.v):
                    self.finished.set()
                    return
        except Exception, e:
                print e 

        # Pick one track at random
        rv = mpx.SQLRowV()
        self.lib.getSQL(rv, str("SELECT id FROM track_view WHERE rating > 3 AND album_rating > 3 ORDER BY mpxrand() LIMIT 1"))
        extract_ids(rv, self.v)
        self.finished.set()

class OptionLastFmTag(BaseOption):    

    def __init__(self, lib, v, xml, mlib, mcs):

         BaseOption.__init__(self, lib, v, xml, mlib, mcs)

    def run(self):
        
        text = self.xml.get_widget("entry-lastfm-tag").get_text()
        rv = mpx.SQLRowV()

        try:
                r = lastfm.TagTopArtists(text)
                a = r.get()

                for artist in a:
                    self.lib.getSQL(rv, str("SELECT id FROM track_view WHERE mb_artist_id ='%s' ORDER BY mpxrand() LIMIT 1" % artist.getMBID()))

        except Exception, e:
                print e

        extract_ids(rv, self.v)
        self.finished.set()

class OptionRandomMix(BaseOption):

    def __init__(self, lib, v, xml, mlib, mcs):

        BaseOption.__init__(self, lib, v, xml, mlib, mcs)

    def run(self):

        [self.RANDOM_genre,
         self.RANDOM_toptune,
         self.RANDOM_markov
        ][ random.randint(0,2) ](self.lib, self.v)

        self.finished.set()

    def RANDOM_genre(self, lib, v):

        choice = random.randint(0,2)
        genre = ""
        rv = mpx.SQLRowV()
        playlist = self.mlib.get_playlist_model()

        if not len(playlist) or choice == 0:

            lib.getSQL(rv, "SELECT id, genre FROM track_view WHERE genre IS NOT NULL ORDER BY mpxrand() LIMIT 1")
            genre = rv[0]["genre"].get_string()
            lib.getSQL(rv, "SELECT id FROM track_view WHERE genre ='%s' ORDER BY mpxrand() LIMIT 2" % genre)

        elif choice == 1: 

            track = mpx.unwrap_boxed_mpxtrack(playlist[len(playlist)-1][9])
            genre = track[mpx.AttributeId.GENRE].get()
            lib.getSQL(rv, "SELECT id FROM track_view WHERE genre ='%s' ORDER BY mpxrand() LIMIT 2" % genre)
        
        elif choice == 2:

            lib.getSQL(rv, "SELECT id FROM track_view ORDER BY mpxrand() LIMIT 2")

        extract_ids(rv, v)

    def RANDOM_toptune(self, lib, v):
    
        rv = mpx.SQLRowV()
        self.lib.getSQL(rv, "SELECT id FROM track_view WHERE rating > 3 AND album_rating > 3 ORDER BY mpxrand() LIMIT 1")
        extract_ids(rv, v)

    def RANDOM_markov(self, lib, v):
        
        track = mpx.unwrap_boxed_mpxtrack(playlist[len(playlist)-1][9])
        id = track[mpx.AttributeId.MPX_TRACK_ID].get()
        markov_id = lib.markovGetRandomProbableTrack(id)

        if markov_id != -1:
            v.append(markov_id)

class OptionTopTunes(BaseOption):

    def __init__(self, lib, v, xml, mlib, mcs):

        BaseOption.__init__(self, lib, v, xml, mlib, mcs)

    def run(self):
    
        rv = mpx.SQLRowV()
        self.lib.getSQL(rv, "SELECT id FROM track_view WHERE rating > 3 AND album_rating > 3 ORDER BY mpxrand() LIMIT 10")
        extract_ids(rv, self.v)
        self.finished.set()

class OptionPlayAll(BaseOption):

    def __init__(self, lib, v, xml, mlib, mcs):

        BaseOption.__init__(self, lib, v, xml, mlib, mcs)

    def run(self):

        rv = mpx.SQLRowV()
        self.lib.getSQL(rv, "SELECT id FROM track_view ORDER BY album_j, track")
        extract_ids(rv, self.v)
        self.finished.set()

class OptionEntertainMe(BaseOption):

    def __init__(self, lib, v, xml, mlib, mcs):

        BaseOption.__init__(self, lib, v, xml, mlib, mcs)

    def run(self):

        [self.ENTERTAIN_Local,
         self.ENTERTAIN_LastFm
        ][random.randint(0,1)]()

        self.finished.set()

    def ENTERTAIN_Local(self):

        rv = mpx.SQLRowV()
        self.lib.getSQL(rv, "SELECT id FROM track_view WHERE pcount > 0 ORDER BY pcount DESC, rating DESC, mpxrand() LIMIT 2")
        extract_ids(rv, self.v)
  
    def ENTERTAIN_LastFm(self):

        r = lastfm.UserTopTracks(self.mcs.key_get_string("lastfm","username"))
        t = r.get()
        random.shuffle(t)
        rv = mpx.SQLRowV()
        artist = t[0].getArtist().replace("'","''")
        title = t[0].getName().replace("'","''")
        self.lib.getSQL(rv, str("SELECT id FROM track_view WHERE artist = '%s' AND title = '%s' LIMIT 1" % (artist,title)))
        extract_ids(rv, self.v)

class OptionSoundsOf(BaseOption):

    def __init__(self, lib, v, xml, mlib, mcs):

        BaseOption.__init__(self, lib, v, xml, mlib, mcs)
 
    def run(self):
    
        active = self.xml.get_widget("cbox-decade").get_active()
        upper = 0
        lower = 0
        if(active == 6):
            lower = 2000
            upper = 3000
        else:
            lower = 1940 + (active * 10)
            upper = 1950 + (active * 10)
        
        
        rv = mpx.SQLRowV()
        for x in range(10):
            self.lib.getSQL(rv, "SELECT id FROM track_view WHERE date >= " + str(lower) + " AND date < " + str(upper) + " ORDER BY mpxrand() LIMIT 1")
        extract_ids(rv, self.v)

        self.finished.set()


class MPXDJ(mpx.Plugin):

    """MPXDJ DJs your music library for you!"""

    def __init__(self,id,player,mcs):
       
        self.id = id 
        self.lib = player.get_library()
        self.covers = player.get_covers()
        self.mlib = player.get_source("36068e19-dfb3-49cd-85b4-52cea16fe0fd"); 
        self.mcs = mcs

        self.xml = gtk.glade.XML("@DATA_DIR@" + "/python-plugins/mpxdj/mpxdj.glade")

        self.widget = self.xml.get_widget("widget")
        self.widget.unparent()

        self.combo = self.xml.get_widget("combobox")

        self.play = self.xml.get_widget("cb-play")

        self.label = self.xml.get_widget("label")

        self.append = self.xml.get_widget("cb-append")
        self.append.connect("toggled", self.on_append_toggled)

        self.go = self.xml.get_widget("button-go")
        self.go.set_sensitive(False)
        self.go.connect("clicked", self.on_button_go)

        self.header_image = self.xml.get_widget("header-image")
        self.header_image.set_from_file("@DATA_DIR@" + "/python-plugins/mpxdj/mpxdj.png")

        try:
            self.icon = gtk.gdk.pixbuf_new_from_file("@DATA_DIR@" + "/python-plugins/mpxdj/mpxdj-icon.png")
        except:
            self.icon = None
            
        options = [
                    "Analyzer",
                    "Entertain Me!",
                    "Play All",
                    "Top Tunes",
                    "Random Mix",
                    "Memory Lane",
                    "Sounds Of...",
                    "Forgotten Gems",
                    "Deja Vu",
                    "Last.fm Tag"
                   ]

        self.callables = [
                            OptionAnalyzer,
                            OptionEntertainMe, 
                            OptionPlayAll, 
                            OptionTopTunes, 
                            OptionRandomMix, 
                            None,
                            OptionSoundsOf, 
                            None,
                            None,
                            OptionLastFmTag 
                         ]


        self.helptexts = [
                "Analyzes the playlist and plays similar Music",
                "Creates a running order composed of the most frequently played tracks.",
                "Plays all tracks in the library",
                "Plays a set number of the most frequently played tracks.",
                "Plays random, but similar tracks",
                "",
                "Plays tracks from a specific decade.",
                "",
                "",
                "Creates a playlist from your music library based on a Last.fm tag"
        ]   

        cell = gtk.CellRendererText()
        self.combo.pack_start(cell)
        self.combo.add_attribute(cell, "text", 0)

        self.store = gtk.ListStore(gobject.TYPE_STRING)
        self.combo.set_model(self.store)
    
        for option in options:
            self.store.append([option])

        self.notebook = self.xml.get_widget("notebook")


        # Finally:
        self.combo.connect("changed", self.on_mode_cbox_changed)
        self.combo.set_active(0)

    def get_icon(self):

        return self.icon

    def get_gui(self):

        return self.widget

    def on_append_toggled(self, cb):

        active = cb.get_active()

        if active:
            self.conn_playlist_end = self.mlib.gobj().connect("playlist-end", self.on_playlist_end)
        else:
            self.mlib.gobj().disconnect(self.conn_playlist_end)

    def on_mode_cbox_changed(self, cbox):

        self.label.set_text(self.helptexts[cbox.get_active()])      
        self.notebook.set_current_page(cbox.get_active())       
        self.go.set_sensitive(self.callables[self.combo.get_active()] is not None)

    def on_playlist_end(self, object, empty):

        self.go.set_sensitive(False)
        self.go.set_label("Working...")
        self.mlib.set_sensitive(False)

        idv = mpx.IdVector()
        klass = self.callables[self.combo.get_active()]
        if klass:
            instance = klass(self.lib, idv, self.xml, self.mlib, self.mcs)
            instance.start () 
        
            while not instance.is_done():
                while gtk.events_pending():
                    gtk.main_iteration()

            instance.stop ()

            self.mlib.append_tracks(idv) 

        self.go.set_label("Go!")
        self.go.set_sensitive(True)
        self.mlib.set_sensitive(True)

    def on_button_go(self, object):

        self.go.set_sensitive(False)
        self.go.set_label("Working...")
        self.mlib.set_sensitive(False)

        idv = mpx.IdVector()
        klass = self.callables[self.combo.get_active()]
        if klass:
            print "Calling class"
            instance = klass(self.lib, idv, self.xml, self.mlib, self.mcs)
            instance.start () 
       
            print "Waiting for done" 
            while not instance.is_done():
                while gtk.events_pending():
                    gtk.main_iteration()

            print "Stopping class"
            instance.stop ()

            print "Appending/playing tracks"
            if self.play.get_active():
                self.mlib.play_tracks(idv)
            else:
                self.mlib.append_tracks(idv) 

        self.go.set_label("Go!")
        self.go.set_sensitive(True)
        self.mlib.set_sensitive(True)

