#@
# -*- coding: utf-8 -*-
# -*- mode:python ; tab-width:4 -*- ex:set tabstop=4 shiftwidth=4 expandtab: -*-
#
# MPX Trackinfo
# (C) 2008 M. Derezynski
#

import mpx
import gtkmm
import time
import pygtk
pygtk.require('2.0')
import gtk
import gobject
import gtk.glade
import urllib
import random
import threading
from mpxapi import lastfm
from gettext import gettext as _
#import musicbrainz2
#import musicbrainz2.webservice as ws

def extract_IDs(rv, v):

    for val in rv:
        v.append(val["id"].get_int())

def extract_IDs_n(rv, v, n):

    for n in range(0, n):
        v.append(rv[n]["id"].get_int())

ui_playlist_popup = """ 
        <ui>
        <menubar name='musiclib-playlist-popup-playlist-list'>
           <menu action='dummy' name='musiclib-playlist-menu-playlist-list'>
               <placeholder name='musiclib-playlist-placeholder-playlist'>
               <menuitem action='mpxdj-enable'/>
               <menu action='mpxdj-playmode'>
                    <menuitem action='mpxdj-mode-analyzer'/>
                    <menuitem action='mpxdj-mode-entertain'/>
                    <menuitem action='mpxdj-mode-toptunes'/>
                    <menuitem action='mpxdj-mode-random'/>
                    <menuitem action='mpxdj-mode-memorylane'/>
                    <menuitem action='mpxdj-mode-soundsof'/>
                    <menuitem action='mpxdj-mode-gems'/>
                    <menuitem action='mpxdj-mode-dejavu'/>
                    <menuitem action='mpxdj-mode-lastfmtag'/>
               </menu>
               </placeholder>
           </menu>
        </menubar>
        </ui>
"""

class BaseOPTION__(threading.Thread):

    def __init__(self, lib, v, xml, queue, mcs):

        threading.Thread.__init__(self)

        self.lib        = lib
        self.xml        = xml
        self.queue      = queue
        self.v          = v
        self.mcs        = mcs
        self.finished   = threading.Event()

    def stop(self):

        self.finished.set()
        self.join()
    
    def is_done(self):

        return self.finished.isSet()

class OPTION__Analyzer(BaseOPTION__):    

    def __init__( self, lib, v, xml, queue, mcs ):

        BaseOPTION__.__init__( self, lib, v, xml, queue, mcs )
        self.range = xml.get_widget("analyzer-range")

    def get_similartracks(self, id):

        try:
                track = self.lib.getTrackById( id ) 
                m = lastfm.SimilarTracks(track[mpx.AttributeId.ARTIST].get(), track[mpx.AttributeId.TITLE].get())
                t = m.get()
        except Exception, e:
                print str(e)

        return t

#    def count_previous_mbid_presence(self, mbid):
#
#        count = 0
#        items = 0
#
#        if (len(self.model)-1) < items:
#
#                items = len(self.model)-1
#
#        for i in range(0,items):
#
#                track = self.model[len(self.model)-items+i]
#                mbid_track = track[mpx.AttributeId.MB_ARTIST_ID].get()
#                if mbid_track == mbid: 
#                        count = count +1
#
#        return count

#    def count_previous_artist_presence(self, artist):
#
#        count = 0
#        items = 9
#
#        if (len(self.model)-1) < items:
#
#                items = len(self.model)-1
#
#        for i in range(0,items):
#
#                track = self.model[len(self.model)-items+i]
#                artist_track = track[mpx.AttributeId.ARTIST].get()
#                if artist_track == artist: 
#                        count = count +1
#
#        return count

    def run_similar_track(self):

        if not len(self.queue): return

        tracks = self.get_similartracks(self.queue[-1:][0])[-1:]
        random.shuffle(tracks)

        for track in tracks: 

                rv = mpx.SQLRowV()

                self.lib.getSQL(rv, str("SELECT id FROM track_view WHERE artist ='%s' AND title = '%s' ORDER BY random() LIMIT 1" % ( track.getArtist().getName().replace("'", "''") , track.getName().replace("'","''") ) ))
                extract_IDs(rv, self.v)

                if len(self.v) > 0: return

    def run_accumulate_tags(self):

        if not len(self.queue): return

        tags  = {} 

        for id in self.queue: 

            try:
                    track = self.lib.getTrackById( id ) 
                    t     = lastfm.TrackTopTags(track[mpx.AttributeId.ARTIST].get(), track[mpx.AttributeId.TITLE].get())
                    ttags = t.get()
                   
                    for tag in ttags: 
                        name = tag.getName()

                        try: 
                            if name in tags:
                                tags[name] = tags[name] + (float(tag.getCount()) / float(len(ttags)))
                            else:
                                tags[name] = float(tag.getCount()) / float(len(ttags))

                        except Exception, e: 
                                print "Exception in run_accumulate_tags: " + str(e)

            except Exception, e: 
                print "Exception in run_accumulate_tags: " + str(e)

        highest_count = 0
        highest_tag   = None

        for tag in tags: 

            if tags[tag] > highest_count:

                highest_tag     = tag 
                highest_count   = tags[tag]

        if highest_tag:
                    
                r = lastfm.TagTopArtists(str(highest_tag))
                a = r.get()

                random.shuffle(a)

                for artist in a: 

                    id = artist.getMBID() 
                    rv = mpx.SQLRowV()

#                    if self.count_previous_mbid_presence(id) < 1:
                    self.lib.getSQL(rv, str("SELECT id FROM track_view WHERE mb_artist_id ='%s' ORDER BY random() LIMIT 1" % id))
                    extract_IDs(rv, self.v)

                    if len(rv) > 0: return

    def run_similar_artist(self):

        if not len(self.queue): return

        try:

                id = self.queue[-1:][0]

                if id:
                    track  = self.lib.getTrackById( id ) 
                    artist = track[mpx.AttributeId.ARTIST].get()
                    rv     = mpx.SQLRowV()

                    print artist
                else:
                    return

        except Exception, e:
                print str(e)

        try:
                tries  = int(self.range.get_value())
                max    = tries
                
                m = lastfm.SimilarArtists(artist)

                a = m.get()[:tries]

                random.shuffle(a)

                while tries > 0:
                        name = str(a[max-tries].getName())

#                        if self.count_previous_artist_presence(name) < 1:

                        self.lib.getSQL(rv, str("SELECT id FROM track_view WHERE artist ='%s' ORDER BY random() LIMIT 1" % name.replace("'","''") ))
                        extract_IDs(rv, self.v)

                        if len(self.v): return

                        tries = tries - 1

        except Exception, e:

                print "Error running run_similar_artist: " + str(e) 

    def run_markov(self):
        
        if not len(self.queue): return

        id = self.queue[-1:][0]

        if id:
            markov_id = self.lib.markovGetRandomProbableTrack(id)
            if markov_id and markov_id != 0:
                self.v.append(markov_id)

    def run(self):

         callables = [self.run_accumulate_tags, self.run_similar_track, self.run_similar_artist, self.run_markov]

         if not len(self.queue):
            self.finished.set()
            return

         # I know this is really lazy, i should just create a list of indexes instead and call the subroutines in sequence
         for n in range(0,5):
 
                 choice = random.randint(0,3)
                 callables[choice]()
 
                 if len(self.v):
                     self.finished.set()
                     return
 
#         if not len(self.v) and id:
#            self.run_markov(self.lib, self.v)

         self.finished.set()

class OPTION__LastFmTag(BaseOPTION__):    

    def __init__(self, lib, v, xml, mlib, mcs, model):

         BaseOPTION__.__init__(self, lib, v, xml, mlib, mcs, model)

    def run(self):
        
        text = self.xml.get_widget("entry-lastfm-tag").get_text()
        rv = mpx.SQLRowV()

        r = lastfm.TagTopArtists(text)
        a = r.get()
        random.shuffle(a)

        idx = 0

        while not len(rv) and len(a):

                r = lastfm.SimilarArtists(a[idx].getName())
                s = r.get()

                random.shuffle(s)
                self.lib.getSQL(rv, str("SELECT id FROM track_view WHERE mb_artist_id ='%s' ORDER BY random() LIMIT 1" % a[0].getMBID()))

                l = 10
                if len(s) < 10: l = len(s)
                   
                for x in range(l):
                    self.lib.getSQL(rv, str("SELECT id FROM track_view WHERE mb_artist_id ='%s' ORDER BY random() LIMIT 1" % s[x].getMBID()))

                extract_IDs(rv, self.v)
                idx = idx + 1

        self.finished.set()

class OPTION__RandomMix(BaseOPTION__):

    def __init__(self, lib, v, xml, mlib, mcs, model):

        BaseOPTION__.__init__(self, lib, v, xml, mlib, mcs, model)

    def run(self):

        if len(self.model):
            self.RANDOM_markov(self.lib, self.v)

        if not len(self.v):
            [self.RANDOM_genre,
             self.RANDOM_toptune,
            ][ random.randint(0,1) ](self.lib, self.v)
    
        self.finished.set()

    def RANDOM_genre(self, lib, v):

        choice = random.randint(0,1)

        rv = mpx.SQLRowV()

        if not len(self.model):

            lib.getSQL(rv, "SELECT id, genre FROM track_view WHERE genre IS NOT NULL ORDER BY random() LIMIT 1")
            genre = rv[0]["genre"].get_string()
            lib.getSQL(rv, "SELECT id FROM track_view WHERE genre ='%s' ORDER BY random() LIMIT 2" % genre)

        elif choice == 0: 

            track = self.model[len(self.model)-1]
            genre = track[mpx.AttributeId.GENRE].get()
            lib.getSQL(rv, "SELECT id FROM track_view WHERE genre ='%s' ORDER BY random() LIMIT 2" % genre)
        
        elif choice == 1:

            lib.getSQL(rv, "SELECT id FROM track_view ORDER BY random() LIMIT 2")

        extract_IDs(rv, v)

    def RANDOM_toptune(self, lib, v):
    
        rv = mpx.SQLRowV()
        self.lib.getSQL(rv, "SELECT id FROM track_view WHERE rating > 3 AND album_rating > 3 ORDER BY random() LIMIT 1")
        extract_IDs(rv, v)

    def RANDOM_markov(self, lib, v):
        
        track = self.model[len(self.model)-1]
        id = track[mpx.AttributeId.MPX_TRACK_ID].get()
        markov_id = lib.markovGetRandomProbableTrack(id)
        if markov_id and markov_id != 0:
            v.append(markov_id)

class OPTION__TopTunes(BaseOPTION__):

    def __init__(self, lib, v, xml, mlib, mcs, model):

        BaseOPTION__.__init__(self, lib, v, xml, mlib, mcs, model)

    def run(self):
    
        rv = mpx.SQLRowV()
        self.lib.getSQL(rv, "SELECT id FROM track_view WHERE rating > 3 AND album_rating > 3 ORDER BY random() LIMIT 10")
        extract_IDs(rv, self.v)
        self.finished.set()

class OPTION__PlayAll(BaseOPTION__):

    def __init__(self, lib, v, xml, mlib, mcs, model):

        BaseOPTION__.__init__(self, lib, v, xml, mlib, mcs, model)

    def run(self):

        rv = mpx.SQLRowV()
        self.lib.getSQL(rv, "SELECT id FROM track_view ORDER BY album_j, track")
        extract_IDs(rv, self.v)
        self.finished.set()

class OPTION__EntertainMe(BaseOPTION__):

    def __init__(self, lib, v, xml, mlib, mcs, model):

        BaseOPTION__.__init__(self, lib, v, xml, mlib, mcs, model)

    def run(self):

        [self.ENTERTAIN_Local,
         self.ENTERTAIN_LastFm
        ][random.randint(0,1)]()

        self.finished.set()

    def ENTERTAIN_Local(self):

        rv = mpx.SQLRowV()
        self.lib.getSQL(rv, "SELECT id FROM track_view WHERE pcount > 10")
    
        if len(rv):
            random.shuffle(rv)
            extract_IDs_n(rv, self.v, 1)
        else:
            self.ENTERTAIN_LastFm()
  
    def ENTERTAIN_LastFm(self):

        r = lastfm.UserTopTracks(self.mcs.key_get_string("lastfm","username"))
        t = r.get()

        for n in range(5):

            random.shuffle(t)
            rv = mpx.SQLRowV()
            artist = t[0].getArtistMBID().replace("'","''")
            self.lib.getSQL(rv, str("SELECT id FROM track_view WHERE mb_artist_id = '%s'" % artist))

            if len(rv):
                random.shuffle(rv)
                extract_IDs_n(rv, self.v, 1)

class OPTION__SoundsOf(BaseOPTION__):

    def __init__(self, lib, v, xml, mlib, mcs, model):

        BaseOPTION__.__init__(self, lib, v, xml, mlib, mcs, model)
 
    def run(self):
    
        active = self.xml.get_widget("cbox-decade").get_active()
        upper = 0
        lower = 0

        if(active == 6):
            lower = 2000
            upper = 3000
        else:
            lower = 1940 + (active * 10)
            upper = 1950 + (active * 10)
        
        rv = mpx.SQLRowV()
        for x in range(10):
            self.lib.getSQL(rv, "SELECT id FROM track_view WHERE date >= " + str(lower) + " AND date < " + str(upper) + " ORDER BY random() LIMIT 1")

        extract_IDs(rv, self.v)
        self.finished.set()

class OPTION__ForgottenGems(BaseOPTION__):

    def __init__(self, lib, v, xml, mlib, mcs, model):

        BaseOPTION__.__init__(self, lib, v, xml, mlib, mcs, model)
 
    def run(self):
   
        rv = mpx.SQLRowV() 
        self.lib.getSQL(rv, "SELECT id FROM track_view WHERE pdate IS NOT NULL AND pcount > 3 ORDER BY pdate ASC")

        if len(rv):
            random.shuffle(rv)
            extract_IDs_n(rv, self.v, 5)

        self.finished.set()

class OPTION__DejaVu(BaseOPTION__):

    def __init__(self, lib, v, xml, mlib, mcs, model):

        BaseOPTION__.__init__(self, lib, v, xml, mlib, mcs, model)
 
    def run(self):
   
        rv = mpx.SQLRowV() 
        self.lib.getSQL(rv, "SELECT id FROM track_view ORDER BY pcount DESC LIMIT 10")

        if len(rv):
            random.shuffle(rv)
            extract_IDs_n(rv, self.v, 5)

        self.finished.set()

class MPXDJ(mpx.Plugin):

    """MPXDJ DJs your music library for you!"""

    def __init__(self,id,youki,mcs):
       
        self.id           = id 
        self.youki        = youki
        self.lib          = youki.get_library()
        self.mcs          = mcs
        self.playmode     = 0

        self.xml          = gtk.glade.XML("@PLUGIN_DIR@" + "/plugins-python/mpxdj/mpxdj.glade")

        self.widget       = self.xml.get_widget("widget")

        self.combo        = self.xml.get_widget("combobox")

        self.header_image = self.xml.get_widget("header-image")
        self.header_image.set_from_file("@PLUGIN_DIR@" + "/plugins-python/mpxdj/mpxdj.png")

        self.notebook     = self.xml.get_widget("notebook")

        self.working      = False
        self.abort        = False

        try:
            self.icon = gtk.gdk.pixbuf_new_from_file("@PLUGIN_DIR@" + "/plugins-python/mpxdj/mpxdj-icon.png")
        except:
            self.icon = None

            
        self.callables = [
            OPTION__Analyzer
#            OPTION__EntertainMe, 
#            OPTION__TopTunes, 
#            OPTION__RandomMix, 
#            None,
#            OPTION__SoundsOf, 
#            OPTION__ForgottenGems,
#            OPTION__DejaVu,
#            OPTION__LastFmTag 
        ]

        self.helptexts = [
            "Analyzes the playlist and plays similar Music"
#            "Creates a running order composed of the most frequently played tracks.",
#            "Plays some of the best rated tracks",
#            "Plays random, but similar tracks",
#            "",
#           "Plays tracks from a specific decade.",
#            "Plays long forgotten but popular tracks.",
#            "Plays a set number of the most frequently played tracks.",
#            "Creates a playlist from your music library based on a Last.fm tag"
        ]   

        self.actionnames = [
            "mpxdj-mode-analyzer"
#            "mpxdj-mode-entertain",
#            "mpxdj-mode-toptunes",
#            "mpxdj-mode-random",
#            "mpxdj-mode-memorylane",
#            "mpxdj-mode-soundsof",
#            "mpxdj-mode-gems",
#            "mpxdj-mode-dejavu",
#            "mpxdj-mode-lastfmtag",
        ] 

        self.options = [
            "Analyzer"
#            "Entertain Me!",
#            "Top Tunes",
#            "Random Mix",
#            "Memory Lane",
#            "Sounds Of...",
#            "Forgotten Gems",
#            "Deja Vu",
#            "Last.fm Tag"
        ]

#        self.action1 = gtk.ToggleAction('mpxdj-enable', "Enable MPXDJ", "", "")
#        self.action2 = gtk.Action('mpxdj-playmode', "MPXDJ Play Mode", "", "")
        
#        self.actiongroup.add_action(self.action1)
#        self.actiongroup.add_action(self.action2)

#        self.action_handler1 = self.action1.connect("toggled", self.on_enable_toggled)

#        self.action = []
#        idx = 0

#        for action in self.actionnames:

#                a = gtk.RadioAction(self.actionnames[idx], self.options[idx], "", "", idx)
#                if not self.callables[idx]: a.set_sensitive(False)
#                self.action.append(a)
#                if idx is not 0: a.set_group(self.action[0])
#                self.actiongroup.add_action(a)
#                idx = idx + 1

#        self.action_handler2 = self.action[0].connect("changed", self.on_mode_changed)
#        self.action[0].set_active(True)

#        self.ui.insert_action_group(self.actiongroup, pos=-1)
#        self.ui.add_ui_from_string(ui_playlist_popup)

        cell = gtk.CellRendererText()
        self.combo.pack_start(cell)
        self.combo.add_attribute(cell, "text", 0)

        self.store = gtk.ListStore(gobject.TYPE_STRING)
        for option in self.options: self.store.append([option])

        self.combo.connect("changed", self.on_mode_cbox_changed)
        self.combo.set_model(self.store)
        self.combo.set_active(0)

        self.working = False
    
        self.queue = []

    def on_mode_changed(self, action, current):

        self.combo.set_active(current.get_current_value())
        self.playmode = current.get_current_value()
        #self.youki.show_plugin(self.id)

    def get_icon(self):

        return self.icon

    def get_gui(self):

        return self.widget

    def activate(self):

        self.conn_metadata_updated = self.youki.gobj().connect("track-new", self.on_metadata_updated)
        self.conn_track_cancelled = self.youki.gobj().connect("track-cancelled", self.on_track_cancelled)

        self.on_metadata_updated([]) 

        qv = self.youki.get_current_play_queue()

        for n in qv: 

            self.queue.append( n )

        #self.action1.handler_block(self.action_handler1)
        #self.action1.set_active(True) 
        #self.action1.handler_unblock(self.action_handler1)
        return True

    def deactivate(self):

        self.youki.gobj().disconnect(self.conn_metadata_updated)
        self.youki.gobj().disconnect(self.conn_track_cancelled)
        #self.action1.handler_block(self.action_handler1)
        #self.action1.set_active(False) 
        #self.action1.handler_unblock(self.action_handler1)
        self.queue = []
        return True

    def on_mode_cbox_changed(self, cbox):

        self.notebook.set_current_page(cbox.get_active())       

        #self.action[0].handler_block(self.action_handler2)
        #self.action[self.combo.get_active()].set_active(True) 
        #self.action[0].handler_unblock(self.action_handler2)

        self.playmode = self.combo.get_active() 

    def on_track_cancelled(self, object):

        if not len(self.queue):
            return

        self.queue.pop()

    def on_metadata_updated(self, object):

        if self.working: return

        try:
                self.working    = True
                track           = self.youki.get_metadata()
                id              = track[mpx.AttributeId.MPX_TRACK_ID].get()
            
                self.queue.append( id ) 

                klass           = self.callables[self.playmode]

                if klass:

                    idv = []

                    instance = klass( self.lib, idv, self.xml, self.queue, self.mcs )
                    instance.start () 

                    print "Calling Instance"
                
                    while not instance.is_done():
                        while gtk.events_pending(): gtk.main_iteration()

                    instance.stop ()

                    if len(idv) and not self.abort:
                        print "Next track: " + str(idv[0])
                        self.youki.queue_next_track(idv[0]) 
                    
        except:
                pass

        self.abort = False
        self.working = False
