#
# -*- coding: utf-8 -*-
# -*- mode:python ; tab-width:4 -*- ex:set tabstop=4 shiftwidth=4 expandtab: -*-
#
# MPX Trackinfo
# (C) 2008 M. Derezynski
#

import mpx
import mpx_musiclib
import time
import pygtk
pygtk.require('2.0')
import gtk
import gobject
import gtk.glade
import urllib
import random
from Ft.Xml.XPath.Context import Context
from Ft.Xml.XPath import Evaluate
from Ft.Xml.Domlette import NonvalidatingReader
from Ft.Xml import EMPTY_NAMESPACE
#import musicbrainz2
#import musicbrainz2.webservice as ws

MBID_NODE_XPATH = u'//mbid'
MATCH_NODE_XPATH = u'//match'


class MPXDJ(mpx.Plugin):

    """MPXDJ DJs your music library for you!"""

    def __init__(self,id,player,mcs):
       
        self.id = id 
        self.lib = player.get_library()
        self.covers = player.get_covers()
        self.mlib = player.get_source("36068e19-dfb3-49cd-85b4-52cea16fe0fd")

        self.xml = gtk.glade.XML("@DATA_DIR@" + "/python-plugins/mpxdj/mpxdj.glade")

        self.widget = self.xml.get_widget("widget")
        self.widget.unparent()

        self.combo = self.xml.get_widget("combobox")

        self.play = self.xml.get_widget("cb-play")

        self.label = self.xml.get_widget("label")

        self.append = self.xml.get_widget("cb-append")
        self.append.connect("toggled", self.on_append_toggled)

        self.go = self.xml.get_widget("button-go")
        self.go.set_sensitive(False)
        self.go.connect("clicked", self.on_button_go)

        self.header_image = self.xml.get_widget("header-image")
        self.header_image.set_from_file("@DATA_DIR@" + "/python-plugins/mpxdj/mpxdj.png")

        try:
            self.icon = gtk.gdk.pixbuf_new_from_file("@DATA_DIR@" + "/python-plugins/mpxdj/mpxdj-icon.png")
        except:
            self.icon = None
            
        options = ["Entertain Me!", "Random Mix", "Play All", "Top Tunes", "New Music", "Memory Lane", "Sounds Of...",
                   "Forgotten Gems", "Deja Vu", "Last.fm Tag"]

        self.callables = [  self.OPTION_entertain_me,
                            self.OPTION_random_mix,
                            self.OPTION_play_all,   
                            self.OPTION_top_tunes,
                            None,
                            None,
                            self.OPTION_sounds_of,
                            None,
                            None,
                            self.OPTION_lastfm_tag
                         ]

        self.helptexts = [
                "Creates a running order composed of the most frequently played tracks.",
                "Plays random, but similar tracks",
                "Plays all tracks in the library",
                "Plays a set number of the most frequently played tracks.",
                "",
                "",
                "Plays tracks from a specific decade.",
                "",
                "",
                "Creates a playlist from your music library based on a Last.fm tag"
        ]   

        cell = gtk.CellRendererText()
        self.combo.pack_start(cell)
        self.combo.add_attribute(cell, "text", 0)

        self.store = gtk.ListStore(gobject.TYPE_STRING)
        self.combo.set_model(self.store)
    
        for option in options:
            self.store.append([option])

        self.notebook = self.xml.get_widget("notebook")


        # Finally:
        self.combo.connect("changed", self.cbox_changed)
        self.combo.set_active(0)

    def on_append_toggled(self, cb):

        active = cb.get_active()

        if active:
            self.conn_playlist_end = self.mlib.gobj().connect("playlist-end", self.on_playlist_end)
        else:
            self.mlib.gobj().disconnect(self.conn_playlist_end)

    def cbox_changed(self, cbox):

        self.label.set_text(self.helptexts[cbox.get_active()])      
        self.notebook.set_current_page(cbox.get_active())       
        self.go.set_sensitive(self.callables[self.combo.get_active()] is not None)

    def extract_ids(self, rv, v):

        for val in rv:
            v.append(val["id"].get_int())

    def OPTION_lastfm_tag(self, lib, v):
        
        text = self.xml.get_widget("entry-lastfm-tag").get_text()
        uri = u"http://ws.audioscrobbler.com/1.0/tag/%s/topartists.xml" % urllib.quote(text)
        lastfm = NonvalidatingReader.parseUri(uri)
        ctx = Context(lastfm)
        mbids = Evaluate(MBID_NODE_XPATH, context=ctx)
        rv = mpx.SQLRowV()
        for mbid in mbids:
            if mbid.firstChild:
                lib.getSQL(rv, str("SELECT id FROM track_view WHERE mb_artist_id ='" + mbid.firstChild.data + "' ORDER BY mpxrand() LIMIT 1"))
        self.extract_ids(rv, v)

    def RANDOM_lastfm(self, lib, v):

        rv = mpx.SQLRowV()
        lib.getSQL(rv, "SELECT id, artist FROM track_view ORDER BY mpxrand() LIMIT 1")
        artist = rv[0]["artist"].get_string()

        try:
            uri = u"http://ws.audioscrobbler.com/1.0/artist/%s/similar.xml" % urllib.quote(artist)
            lastfm = NonvalidatingReader.parseUri(uri)
            ctx = Context(lastfm)

            mbids_xml = Evaluate(MBID_NODE_XPATH, context=ctx)
            mbids = []
       
            for mbid in mbids_xml: 
                if mbid.firstChild:
                    mbids.append(str(mbid.firstChild.data))
            
            matches_xml = Evaluate(MATCH_NODE_XPATH, context=ctx)
            matches = []
       
            for match in matches_xml: 
                if match.firstChild:
                    matches.append(float(match.firstChild.data))

            for mbid in mbids:
                if matches[mbids.index(mbid)] > 50:
                    lib.getSQL(rv, str("SELECT id FROM track_view WHERE mb_artist_id ='" + mbid + "' ORDER BY mpxrand() LIMIT 1"))
        except:
            print "Error running random_lastfm"

        self.extract_ids(rv, v)

    def RANDOM_lastfm2(self, lib, v):

        rv = mpx.SQLRowV()
        lib.getSQL(rv, "SELECT id, artist, title FROM track_view ORDER BY mpxrand() LIMIT 1")
        artist = rv[0]["artist"].get_string()
        title = rv[0]["title"].get_string()

        try:
            uri = u"http://ws.audioscrobbler.com/1.0/track/%s/%s/similar.xml" % (urllib.quote(artist), urllib.quote(title))
            lastfm = NonvalidatingReader.parseUri(uri)
            ctx = Context(lastfm)

            artists_xml = Evaluate("//track/artist/name", context=ctx)
            artists = []
       
            for artist in artists_xml: 
                if artist.firstChild:
                    artists.append(str(artist.firstChild.data))
            
            tracks_xml = Evaluate("//track/name", context=ctx)
            tracks = []
       
            for track in tracks_xml: 
                if track.firstChild:
                    tracks.append(str(track.firstChild.data))

            matches_xml = Evaluate("//track/match", context=ctx)
            matches = []
       
            for match in matches_xml: 
                if match.firstChild:
                    matches.append(float(match.firstChild.data))

            for artist in artists:
                track = tracks[artists.index(artist)]
                lib.getSQL(rv, str("SELECT id FROM track_view WHERE artist LIKE '%s' AND title LIKE '%s' LIMIT 1" % (artist.replace("'","''"), track.replace("'","''"))))
        except:
            print "Error fetching Last.fm document"

        self.extract_ids(rv, v)

    def RANDOM_lastfm3(self, lib, v):

        rv = mpx.SQLRowV()
        lib.getSQL(rv, "SELECT id, artist, title FROM track_view ORDER BY mpxrand() LIMIT 1")
        artist = rv[0]["artist"].get_string()
        title = rv[0]["title"].get_string()

        try:
            uri = u"http://ws.audioscrobbler.com/1.0/artist/%s/toptracks.xml" % (urllib.quote(artist), urllib.quote(title))
            lastfm = NonvalidatingReader.parseUri(uri)
            ctx = Context(lastfm)

            tracks_xml = Evaluate("//track/name", context=ctx)
            tracks = []
       
            for track in tracks_xml: 
                if track.firstChild:
                    tracks.append(str(track.firstChild.data))

            for track in tracks:
                lib.getSQL(rv, str("SELECT id FROM track_view WHERE artist LIKE '%s' AND title LIKE '%s' LIMIT 1" % (artist.replace("'","''"), track.replace("'","''"))))
        except:
            print "Error fetching Last.fm document"

        random.shuffle(rv)
        self.extract_ids(rv, v)

    def RANDOM_genre(self, lib, v):

        rv = mpx.SQLRowV()
        lib.getSQL(rv, "SELECT id, genre FROM track_view WHERE genre IS NOT NULL ORDER BY mpxrand() LIMIT 1")
        genre = rv[0]["genre"].get_string()
        lib.getSQL(rv, "SELECT id FROM track_view WHERE genre ='%s' ORDER BY mpxrand() LIMIT 9" % genre)
        self.extract_ids(rv, v)


    def OPTION_random_mix(self, lib, v):

        random_algos = [ self.RANDOM_lastfm, self.RANDOM_lastfm2, self.RANDOM_lastfm3, self.RANDOM_genre ]
        random_algos[ random.randint(0,3) ](lib, v)

    def OPTION_sounds_of(self, lib, v):
    
        active = self.xml.get_widget("cbox-decade").get_active()
        upper = 0
        lower = 0
        if(active == 6):
            lower = 2000
            upper = 3000
        else:
            lower = 1940 + (active * 10)
            upper = 1950 + (active * 10)
        
        
        rv = mpx.SQLRowV()
        for x in range(10):
            lib.getSQL(rv, "SELECT id FROM track_view WHERE date >= " + str(lower) + " AND date < " + str(upper) + " ORDER BY mpxrand() LIMIT 1")
        self.extract_ids(rv, v)

    def OPTION_top_tunes(self, lib, v):
    
        rv = mpx.SQLRowV()
        lib.getSQL(rv, "SELECT id FROM track_view WHERE rating > 3 AND album_rating > 3 ORDER BY mpxrand() LIMIT 10")
        self.extract_ids(rv, v)

    def OPTION_play_all(self, lib, v):

        rv = mpx.SQLRowV()
        lib.getSQL(rv, "SELECT id FROM track_view ORDER BY album, track")
        self.extract_ids(rv, v)

    def OPTION_entertain_me(self, lib, v):

        rv = mpx.SQLRowV()
        lib.getSQL(rv, "SELECT id FROM track_view WHERE pcount > 0 ORDER BY pcount DESC, rating DESC, mpxrand() LIMIT 10")
        self.extract_ids(rv, v)

    def get_icon(self):

        return self.icon

    def on_playlist_end(self, object):

        idv = mpx_musiclib.TrackIdVector()
        callable = self.callables[self.combo.get_active()]
        if(callable):
            callable(self.lib, idv)
            if idv:
                self.mlib.append_tracks(idv) 

    def on_button_go(self, object):

        idv = mpx_musiclib.TrackIdVector()
        callable = self.callables[self.combo.get_active()]
        if(callable):
            callable(self.lib, idv)
            if idv:
                if self.play.get_active():
                    self.mlib.play_tracks(idv)
                else:
                    self.mlib.append_tracks(idv) 


    def get_gui(self):
        return self.widget
