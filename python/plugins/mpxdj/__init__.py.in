#
# -*- coding: utf-8 -*-
# -*- mode:python ; tab-width:4 -*- ex:set tabstop=4 shiftwidth=4 expandtab: -*-
#
# MPX Trackinfo
# (C) 2008 M. Derezynski
#

import mpx
import gtkmm
import time
import pygtk
pygtk.require('2.0')
import gtk
import gobject
import gtk.glade
import urllib
import random
import threading
from Ft.Xml.XPath.Context import Context
from Ft.Xml.XPath import Evaluate
from Ft.Xml.Domlette import NonvalidatingReader
from Ft.Xml import EMPTY_NAMESPACE
#import musicbrainz2
#import musicbrainz2.webservice as ws

def extract_ids(rv, v):

    for val in rv:
        v.append(val["id"].get_int())

class BaseOption(threading.Thread):

    def __init__(self, lib, v, xml, mlib):

        threading.Thread.__init__(self)
        self.lib = lib
        self.xml = xml
        self.mlib = mlib
        self.v = v
        self.finished = threading.Event()

    def stop(self):

        self.finished.set()
        self.join()
    
    def is_done(self):

        return self.finished.isSet()

class OptionAnalyzer(BaseOption):    

    def __init__(self, lib, v, xml, mlib):

         BaseOption.__init__(self, lib, v, xml, mlib)

    def get_tracktags(self, mpxtrack):

        uri     = u"http://ws.audioscrobbler.com/1.0/track/%s/%s/toptags.xml" % (urllib.quote(mpxtrack[mpx.AttributeId.ARTIST].get()), urllib.quote(mpxtrack[mpx.AttributeId.TITLE].get()))
        lastfm  = NonvalidatingReader.parseUri(uri)
        ctx     = Context(lastfm)

        tags    = []
        cnts    = []
        n_xml   = Evaluate("//name", context=ctx)
        c_xml   = Evaluate("//count", context=ctx)

        for cnt in c_xml:
            if cnt.firstChild:
                cnts.append(int(cnt.firstChild.data))

        for nam in n_xml:
            if nam.firstChild:
                tags.append([str(nam.firstChild.data), cnts[n_xml.index(nam)]])

        return tags

    def get_similartracks(self, mpxtrack):

        uri     = u"http://ws.audioscrobbler.com/1.0/track/%s/%s/similar.xml" % (urllib.quote(mpxtrack[mpx.AttributeId.ARTIST].get()), urllib.quote(mpxtrack[mpx.AttributeId.TITLE].get()))
        lastfm  = NonvalidatingReader.parseUri(uri)
        ctx     = Context(lastfm)

        a_xml   = Evaluate("//artist/name", context=ctx)
        t_xml   = Evaluate("//track/name", context=ctx)

        stracks = []

        for i in range(0,len(a_xml)-1):
            stracks.append({"artist":a_xml[i].firstChild.data,
                            "title":t_xml[i].firstChild.data})

        return stracks

    def run_similar_track(self):

        playlist    = self.mlib.get_playlist_model()

        if not len(playlist):

            return

        track       = mpx.unwrap_boxed_mpxtrack(playlist[len(playlist)-1][9])
        stracks     = self.get_similartracks(track)
          
        random.shuffle(stracks)

        for strack in stracks: 

                rv = mpx.SQLRowV()
                self.lib.getSQL(rv, str("SELECT id FROM track_view WHERE artist ='%s' AND title = '%s' LIMIT 1" % ( strack["artist"].replace("\'", "\'\'") , strack["title"].replace("\'","\'\'") ) ))
                extract_ids(rv, self.v)

                if len(rv) > 0:
                    self.finished.set()
                    return

        self.finished.set()

    def run_accumulate_tags(self):

        playlist    = self.mlib.get_playlist_model()
        tags        = {} 
        items       = 10 

        if len(playlist) < items:
            items = len(playlist)

        for i in range(len(playlist)-items,len(playlist)-1):

            track   = mpx.unwrap_boxed_mpxtrack(playlist[i][9])
            ttags   = self.get_tracktags(track)
           
            for tag in ttags: 
                
                if tag[0] in tags:
                    tags[tag[0]] = tags[tag[0]] + tag[1] 
                else:
                    tags[tag[0]] = tag[1] 

        highest_count = 0
        highest_tag   = None

        for tag in tags: 

            if tags[tag] > highest_count:

                highest_tag     = tag 
                highest_count   = tags[tag]

        if highest_tag:

                uri     = u"http://ws.audioscrobbler.com/1.0/tag/%s/topartists.xml" % urllib.quote(str(highest_tag))
                lastfm  = NonvalidatingReader.parseUri(uri)
                ctx     = Context(lastfm)
                mbids   = Evaluate("//mbid", context=ctx)

                random.shuffle(mbids)

                for mbid in mbids: 

                    if mbid.firstChild:

                        rv = mpx.SQLRowV()
                        self.lib.getSQL(rv, str("SELECT id FROM track_view WHERE mb_artist_id ='" + mbid.firstChild.data + "' ORDER BY mpxrand() LIMIT 1"))
                        extract_ids(rv, self.v)

                        if len(rv) > 0:
                            self.finished.set()
                            return

        self.finished.set()

    def run(self):

        self.run_similar_track()

        if not len(self.v):
            self.run_accumulate_tags()

class OptionLastFmTag(BaseOption):    

    def __init__(self, lib, v, xml, mlib):

         BaseOption.__init__(self, lib, v, xml, mlib)

    def run(self):
        
        text = self.xml.get_widget("entry-lastfm-tag").get_text()
        rv = mpx.SQLRowV()

        try:
                uri     = u"http://ws.audioscrobbler.com/1.0/tag/%s/topartists.xml" % urllib.quote(text)
                doc     = NonvalidatingReader.parseUri(uri)
                ctx     = Context(doc)
                mbids   = Evaluate("//mbid", context=ctx)

                for mbid in mbids:
                    if mbid.firstChild:
                        self.lib.getSQL(rv, str("SELECT id FROM track_view WHERE mb_artist_id ='" + mbid.firstChild.data + "' ORDER BY mpxrand() LIMIT 1"))
        except:
                pass

        extract_ids(rv, self.v)
        self.finished.set()

class OptionRandomMix(BaseOption):

    def __init__(self, lib, v, xml, mlib):

        BaseOption.__init__(self, lib, v, xml, mlib)

    def run(self):

        callables = [
            self.RANDOM_LastFm,
            self.RANDOM_LastFm2,
            self.RANDOM_LastFm3,
            self.RANDOM_genre,
            self.RANDOM_toptune
        ]

        callables[ random.randint(0,4) ](self.lib, self.v)

        self.finished.set()

    def RANDOM_LastFm(self, lib, v):

        choice      = random.randint(0,1)
        artist      = ""
        rv          = mpx.SQLRowV()
        playlist    = self.mlib.get_playlist_model()

        if not len(playlist) or choice == 0:

            lib.getSQL(rv, "SELECT id, artist FROM track_view ORDER BY mpxrand() LIMIT 1")
            artist = rv[0]["artist"].get_string()

        else: 

            track = mpx.unwrap_boxed_mpxtrack(playlist[len(playlist)-1][9])
            artist = track[mpx.AttributeId.ARTIST].get()


        try:
            uri = u"http://ws.audioscrobbler.com/1.0/artist/%s/similar.xml" % urllib.quote(artist)
            lastfm = NonvalidatingReader.parseUri(uri)

            ctx = Context(lastfm)

            mbids_xml = Evaluate("//mbid", context=ctx)
            mbids = []
       
            for mbid in mbids_xml: 
                if mbid.firstChild:
                    mbids.append(str(mbid.firstChild.data))
            
            matches_xml = Evaluate("//match", context=ctx)
            matches = []
       
            for match in matches_xml: 
                if match.firstChild:
                    matches.append(float(match.firstChild.data))

            rv = mpx.SQLRowV()

            for mbid in mbids:
                if matches[mbids.index(mbid)] > 50:
                    lib.getSQL(rv, str("SELECT id FROM track_view WHERE mb_artist_id ='" + mbid + "' ORDER BY mpxrand() LIMIT 1"))

        except:
            print "Error running RANDOM_LastFm"

        extract_ids(rv, v)

    def RANDOM_LastFm2(self, lib, v):

        choice      = random.randint(0,1)
        artist      = ""
        title       = ""
        rv          = mpx.SQLRowV()
        playlist    = self.mlib.get_playlist_model()

        if not len(playlist) or choice == 0:

            lib.getSQL(rv, "SELECT id, artist, title FROM track_view ORDER BY mpxrand() LIMIT 1")
            artist = rv[0]["artist"].get_string()
            title  = rv[0]["title"].get_string()

        else:

            track    = mpx.unwrap_boxed_mpxtrack(playlist[len(playlist)-1][9])
            artist = track[mpx.AttributeId.ARTIST].get()
            title  = track[mpx.AttributeId.TITLE].get()


        try:
            uri     = u"http://ws.audioscrobbler.com/1.0/track/%s/%s/similar.xml" % (urllib.quote(artist), urllib.quote(title))
            lastfm  = NonvalidatingReader.parseUri(uri)
            ctx     = Context(lastfm)

            artists_xml = Evaluate("//track/artist/name", context=ctx)
            artists     = []
       
            for artist in artists_xml: 
                if artist.firstChild:
                    artists.append(str(artist.firstChild.data))
            
            tracks_xml  = Evaluate("//track/name", context=ctx)
            tracks      = []
       
            for track in tracks_xml: 
                if track.firstChild:
                    tracks.append(str(track.firstChild.data))

            matches_xml = Evaluate("//track/match", context=ctx)
            matches     = []
       
            for match in matches_xml: 
                if match.firstChild:
                    matches.append(float(match.firstChild.data))

            rv = mpx.SQLRowV()

            for artist in artists:
                track = tracks[artists.index(artist)]
                lib.getSQL(rv, str("SELECT id FROM track_view WHERE artist LIKE '%s' AND title LIKE '%s' LIMIT 1" % (artist.replace("'","''"), track.replace("'","''"))))

        except:
            print "Error in RANDOM_LastFm2"

        extract_ids(rv, v)

    def RANDOM_LastFm3(self, lib, v):

        choice      = random.randint(0,1)
        artist      = ""
        rv          = mpx.SQLRowV()
        playlist    = self.mlib.get_playlist_model()

        if not len(playlist) or choice == 0:

            lib.getSQL(rv, "SELECT id, artist, title FROM track_view ORDER BY mpxrand() LIMIT 1")
            artist = rv[0]["artist"].get_string()

        else: 

            track    = mpx.unwrap_boxed_mpxtrack(playlist[len(playlist)-1][9])
            artist   = track[mpx.AttributeId.ARTIST].get()


        try:
            uri     = u"http://ws.audioscrobbler.com/1.0/artist/%s/toptracks.xml" % (urllib.quote(artist))
            lastfm  = NonvalidatingReader.parseUri(uri)
            ctx     = Context(lastfm)

            tracks_xml = Evaluate("//track/name", context=ctx)
            tracks     = []
       
            for track in tracks_xml: 
                if track.firstChild:
                    tracks.append(str(track.firstChild.data))

            max_loop = random.randint(2,5)
            if len(tracks) < max_loop:
                max_loop = len(tracks)

            offset = random.randint(0,len(tracks)-max_loop)

            for idx in range(max_loop):
                lib.getSQL(rv, str("SELECT id FROM track_view WHERE artist LIKE '%s' AND title LIKE '%s' LIMIT 1" % (artist.replace("'","''"), tracks[idx+offset].replace("'","''"))))
        except:
            print "Error in RANDOM_LastFm3"

        random.shuffle(rv)
        extract_ids(rv, v)

    def RANDOM_genre(self, lib, v):

        choice      = random.randint(0,1)
        genre       = ""
        rv          = mpx.SQLRowV()
        playlist    = self.mlib.get_playlist_model()

        if not len(playlist) or choice == 0:

            lib.getSQL(rv, "SELECT id, genre FROM track_view WHERE genre IS NOT NULL ORDER BY mpxrand() LIMIT 1")
            genre = rv[0]["genre"].get_string()

        else: 

            track    = mpx.unwrap_boxed_mpxtrack(playlist[len(playlist)-1][9])
            genre    = track[mpx.AttributeId.GENRE].get()

        lib.getSQL(rv, "SELECT id FROM track_view WHERE genre ='%s' ORDER BY mpxrand() LIMIT 5" % genre)

        extract_ids(rv, v)

    def RANDOM_toptune(self, lib, v):
    
        rv = mpx.SQLRowV()
        self.lib.getSQL(rv, "SELECT id FROM track_view WHERE rating > 3 AND album_rating > 3 ORDER BY mpxrand() LIMIT 1")

        extract_ids(rv, v)

class OptionTopTunes(BaseOption):

    def __init__(self, lib, v, xml, mlib):

        BaseOption.__init__(self, lib, v, xml, mlib)

    def run(self):
    
        rv = mpx.SQLRowV()
        self.lib.getSQL(rv, "SELECT id FROM track_view WHERE rating > 3 AND album_rating > 3 ORDER BY mpxrand() LIMIT 10")
        extract_ids(rv, self.v)
        self.finished.set()

class OptionPlayAll(BaseOption):

    def __init__(self, lib, v, xml, mlib):

        BaseOption.__init__(self, lib, v, xml, mlib)

    def run(self):

        rv = mpx.SQLRowV()
        lib.getSQL(rv, "SELECT id FROM track_view ORDER BY album, track")
        extract_ids(rv, v)
        self.finished.set()

class OptionEntertainMe(BaseOption):

    def __init__(self, lib, v, xml, mlib):

        BaseOption.__init__(self, lib, v, xml, mlib)

    def run(self):

        rv = mpx.SQLRowV()
        self.lib.getSQL(rv, "SELECT id FROM track_view WHERE pcount > 0 ORDER BY pcount DESC, rating DESC, mpxrand() LIMIT 10")
        extract_ids(rv, v)
        self.finished.set()
  
class OptionSoundsOf(BaseOption):

    def __init__(self, lib, v, xml, mlib):

        BaseOption.__init__(self, lib, v, xml, mlib)
 
    def run(self):
    
        active = self.xml.get_widget("cbox-decade").get_active()
        upper = 0
        lower = 0
        if(active == 6):
            lower = 2000
            upper = 3000
        else:
            lower = 1940 + (active * 10)
            upper = 1950 + (active * 10)
        
        
        rv = mpx.SQLRowV()
        for x in range(10):
            self.lib.getSQL(rv, "SELECT id FROM track_view WHERE date >= " + str(lower) + " AND date < " + str(upper) + " ORDER BY mpxrand() LIMIT 1")
        extract_ids(rv, self.v)

        self.finished.set()


class MPXDJ(mpx.Plugin):

    """MPXDJ DJs your music library for you!"""

    def __init__(self,id,player,mcs):
       
        self.id = id 
        self.lib = player.get_library()
        self.covers = player.get_covers()
        self.mlib = player.get_source("36068e19-dfb3-49cd-85b4-52cea16fe0fd"); 

        self.xml = gtk.glade.XML("@DATA_DIR@" + "/python-plugins/mpxdj/mpxdj.glade")

        self.widget = self.xml.get_widget("widget")
        self.widget.unparent()

        self.combo = self.xml.get_widget("combobox")

        self.play = self.xml.get_widget("cb-play")

        self.label = self.xml.get_widget("label")

        self.append = self.xml.get_widget("cb-append")
        self.append.connect("toggled", self.on_append_toggled)

        self.go = self.xml.get_widget("button-go")
        self.go.set_sensitive(False)
        self.go.connect("clicked", self.on_button_go)

        self.header_image = self.xml.get_widget("header-image")
        self.header_image.set_from_file("@DATA_DIR@" + "/python-plugins/mpxdj/mpxdj.png")

        try:
            self.icon = gtk.gdk.pixbuf_new_from_file("@DATA_DIR@" + "/python-plugins/mpxdj/mpxdj-icon.png")
        except:
            self.icon = None
            
        options = [
                    "Analyzer",
                    "Entertain Me!",
                    "Play All",
                    "Top Tunes",
                    "Random Mix",
                    "Memory Lane",
                    "Sounds Of...",
                    "Forgotten Gems",
                    "Deja Vu",
                    "Last.fm Tag"
                   ]

        self.callables = [
                            OptionAnalyzer,
                            OptionEntertainMe, 
                            OptionPlayAll, 
                            OptionTopTunes, 
                            OptionRandomMix, 
                            None,
                            OptionSoundsOf, 
                            None,
                            None,
                            OptionLastFmTag 
                         ]


        self.helptexts = [
                "Analyzes the playlist and plays similar Music",
                "Creates a running order composed of the most frequently played tracks.",
                "Plays all tracks in the library",
                "Plays a set number of the most frequently played tracks.",
                "Plays random, but similar tracks",
                "",
                "Plays tracks from a specific decade.",
                "",
                "",
                "Creates a playlist from your music library based on a Last.fm tag"
        ]   

        cell = gtk.CellRendererText()
        self.combo.pack_start(cell)
        self.combo.add_attribute(cell, "text", 0)

        self.store = gtk.ListStore(gobject.TYPE_STRING)
        self.combo.set_model(self.store)
    
        for option in options:
            self.store.append([option])

        self.notebook = self.xml.get_widget("notebook")


        # Finally:
        self.combo.connect("changed", self.on_mode_cbox_changed)
        self.combo.set_active(0)

    def get_icon(self):

        return self.icon

    def get_gui(self):

        return self.widget

    def on_append_toggled(self, cb):

        active = cb.get_active()

        if active:
            self.conn_playlist_end = self.mlib.gobj().connect("playlist-end", self.on_playlist_end)
        else:
            self.mlib.gobj().disconnect(self.conn_playlist_end)

    def on_mode_cbox_changed(self, cbox):

        self.label.set_text(self.helptexts[cbox.get_active()])      
        self.notebook.set_current_page(cbox.get_active())       
        self.go.set_sensitive(self.callables[self.combo.get_active()] is not None)

    def on_playlist_end(self, object, empty):

        self.go.set_sensitive(False)
        self.go.set_label("Working...")
        self.mlib.set_sensitive(False)

        idv = mpx.IdVector()
        klass = self.callables[self.combo.get_active()]
        if klass:
            instance = klass(self.lib, idv, self.xml, self.mlib)
            instance.start () 
        
            while not instance.is_done():
                while gtk.events_pending():
                    gtk.main_iteration()

            instance.stop ()

            self.mlib.append_tracks(idv) 

        self.go.set_label("Go!")
        self.go.set_sensitive(True)
        self.mlib.set_sensitive(True)

    def on_button_go(self, object):

        self.go.set_sensitive(False)
        self.go.set_label("Working...")
        self.mlib.set_sensitive(False)

        idv = mpx.IdVector()
        klass = self.callables[self.combo.get_active()]
        if klass:
            instance = klass(self.lib, idv, self.xml, self.mlib)
            instance.start () 
        
            while not instance.is_done():
                while gtk.events_pending():
                    gtk.main_iteration()

            instance.stop ()

            if self.play.get_active():
                self.mlib.play_tracks(idv)
            else:
                self.mlib.append_tracks(idv) 

        self.go.set_label("Go!")
        self.go.set_sensitive(True)
        self.mlib.set_sensitive(True)

