
# -*- coding: utf-8 -*-
# -*- mode:python ; tab-width:4 -*- ex:set tabstop=4 shiftwidth=4 expandtab: -*-
#
# MPX Trackinfo
# (C) 2008 M. Derezynski
#

import mpx
import pygtk
pygtk.require('2.0')
import gtk
import gtk.glade
import gobject
import pygst
pygst.require('0.10')
import gst
import pango
import time
import os
import thread
import musicbrainz2
import musicbrainz2.webservice as ws

class WaitSecond:

        def __init__(self):

                self.initialtime = time.time()

        def waitsecond(self):

                return        
                t = time.time() # Only to do something in the loop
                while (t - self.initialtime) < 2: 
                        t = time.time()

                self.initialtime = time.time()

class LinkTag(gtk.TextTag):

    __gsignals__ = {
            'url-clicked' : (gobject.SIGNAL_RUN_LAST, gobject.TYPE_NONE,
                (gobject.TYPE_STRING,))
        }

    def __init__(self, link):

        gtk.TextTag.__init__(self)
        self.set_property("foreground", "#0000ff")
        self.link = link

    def do_event(self, event_obj, event, iter):     

        if event.type == gtk.gdk.BUTTON_PRESS:
             if event.button == 1:
                self.emit("url-clicked", self.link)

class TrackInfo:

    def __init__(self, xml):

        self.wait = WaitSecond()
        self.q = ws.Query(musicbrainz2.webservice.WebService("www.uk.musicbrainz.org"))
        self.wsinc = musicbrainz2.webservice.TrackIncludes(trackRelations=True,artist=True,puids=True,releases=True,artistRelations=True,releaseRelations=True,urlRelations=True)
        self.wsinc_release = musicbrainz2.webservice.ReleaseIncludes(releaseEvents=True,releaseRelations=True,urlRelations=True)

        self.xml = xml
        self.notebook = self.xml.get_widget("notebook-track-info-1")
        self.textview = self.xml.get_widget("textview")
        self.textview.connect("motion-notify-event", self.on_view_motion_notify)
        self.throb = self.xml.get_widget("throb")
        self.throb.set_from_file("@DATA_DIR@" + "/images/throbber.gif")
        self.notebook.set_current_page(0)

        self.buf = self.textview.get_buffer()

        self.textTagBold = gtk.TextTag()
        self.textTagBold.set_property("weight", pango.WEIGHT_BOLD)
        self.buf.get_tag_table().add(self.textTagBold)
        
        self.textTagCenter = gtk.TextTag()
        self.textTagCenter.set_property("justification", gtk.JUSTIFY_CENTER) 
        self.buf.get_tag_table().add(self.textTagCenter)

        self.textTagLarge = gtk.TextTag()
        self.textTagLarge.set_property("size-points", 16) 
        self.buf.get_tag_table().add(self.textTagLarge)

        self.textTagSlant = gtk.TextTag()
        self.textTagSlant.set_property("style", pango.STYLE_ITALIC) 
        self.buf.get_tag_table().add(self.textTagSlant)

        self.textTagUnderline = gtk.TextTag()
        self.textTagUnderline.set_property("underline", pango.UNDERLINE_SINGLE) 
        self.buf.get_tag_table().add(self.textTagUnderline)

        self.Hand = False

        self.player = gst.Pipeline("player")
        self.source = gst.element_factory_make("giosrc", "file-source")
        self.player.add(self.source)
        self.demuxer = gst.element_factory_make("decodebin", "demuxer")
        self.player.add(self.demuxer)
        self.demuxer.connect("new-decoded-pad", self.demuxer_callback)
        self.puid = gst.element_factory_make("puid", "puid")
        self.player.add(self.puid)
        self.gotPuid = False
        self.puid.set_property('musicdns-id', '234e8289d5a5fd4b29127bd114309954')
        self.audiosink = gst.element_factory_make("fakesink", "audio-output")
        self.player.add(self.audiosink)
        gst.element_link_many(self.source, self.demuxer)
        gst.element_link_many(self.puid, self.audiosink)
        self.bus = self.player.get_bus()
        self.bus.add_signal_watch()
        self.bus.connect('message', self.on_message)

    def demuxer_callback(self, demuxer, pad, arg):

        dec_pad = self.puid.get_pad("sink")
        pad.link(dec_pad)

    def on_message(self, bus, message):    

        t = message.type
        if t == gst.MESSAGE_EOS:
            puid = self.puid.get_property('puid')
            if puid and len(puid) > 0:
                result = ws.TrackFilter(puid=puid) 
                tracks = self.q.getTracks(result)

                if len(tracks) > 0:

                    self.track[mpx.AttributeId.MB_TRACK_ID].init()
                    self.track[mpx.AttributeId.MB_TRACK_ID].val().set_string(str(tracks[0].getTrack().getId()))

                    mbtrack = self.q.getTrackById(tracks[0].getTrack().getId(), self.wsinc) 
                    artist = mbtrack.getArtist()

                    self.track[mpx.AttributeId.MB_ARTIST_ID].init()
                    self.track[mpx.AttributeId.MB_ARTIST_ID].val().set_string(str(artist.getId()))

                    if not self.track[mpx.AttributeId.ARTIST].is_initialized():
                        self.track[mpx.AttributeId.ARTIST].init()
                        self.track[mpx.AttributeId.ARTIST].val().set_string(str(artist.getName()))
                    
                    if not self.track[mpx.AttributeId.TITLE].is_initialized():
                        self.track[mpx.AttributeId.TITLE].init()
                        self.track[mpx.AttributeId.TITLE].val().set_string(str(mbtrack.getTitle()))

                    self.gotPuid = True
                    self.show([])

            self.gotPuid = True
    
    def clear(self):

        self.buf.set_text('')

    def on_view_motion_notify(self, widget, event):

        if event.is_hint: 

            x, y, state = event.window.get_pointer()
        
        else:

            x = event.x
            y = event.y
            state = event.state

        xb, yb = self.textview.window_to_buffer_coords(gtk.TEXT_WINDOW_WIDGET, x, y)
        iter = self.textview.get_iter_at_location(xb, yb)
        tags = iter.get_tags() 

        for tag in tags:

            if isinstance(tag, LinkTag):
                window = self.textview.get_window(gtk.TEXT_WINDOW_TEXT)                
                cursor = gtk.gdk.cursor_new_from_name(gtk.gdk.display_get_default(), "hand2")
                window.set_cursor(cursor)
                self.Hand = True
                return False

        if self.Hand:

            window = self.textview.get_window(gtk.TEXT_WINDOW_TEXT)                
            cursor = gtk.gdk.cursor_new_from_name(gtk.gdk.display_get_default(), "xterm")
            window.set_cursor(cursor)
            self.Hand = False

        return False

    def run(self,track):

        self.notebook.set_current_page(1)

        self.track = track
        self.Done = False
        self.show([])
        #self.thread = thread.start_new_thread(self.show, (self,))

        #while not self.Done:
        #        while gtk.events_pending():
        #                gtk.main_iteration()

        self.notebook.set_current_page(2)

    def show(self, blah):

        track = self.track

        if not self.gotPuid and not track[mpx.AttributeId.MB_TRACK_ID].is_initialized():

            if track.get(mpx.AttributeId.LOCATION).val().get_string()[:4] == "file":

                self.player.get_by_name("file-source").set_property('location', track.get(mpx.AttributeId.LOCATION).val().get_string())
                self.player.set_state(gst.STATE_PLAYING)

                while not self.gotPuid: 
                    while gtk.events_pending():
                        gtk.main_iteration()

        self.gotPuid = False

        try:
            self.buf.delete(self.buf.get_start_iter(), self.buf.get_end_iter())
            self.buf.insert(self.buf.get_end_iter(), "\n")

            try:
                self.buf.insert_with_tags(self.buf.get_end_iter(), "Lyrics", self.textTagLarge, self.textTagUnderline)
                self.buf.insert(self.buf.get_end_iter(), "\n\n")
                lyricwiki = mpx.LyricWiki(track[mpx.AttributeId.ARTIST].val().get_string(), track[mpx.AttributeId.TITLE].val().get_string())
                lyrics = lyricwiki.run()
                self.buf.insert(self.buf.get_end_iter(), lyrics)
            except:
                print "No Lyrics" 
            
            try:
                self.buf.insert(self.buf.get_end_iter(), "\n\n")
                self.buf.insert_with_tags(self.buf.get_end_iter(), "About " + track[mpx.AttributeId.ARTIST].val().get_string(), self.textTagLarge, self.textTagUnderline)
                self.buf.insert(self.buf.get_end_iter(), "\n\n")
                lastfmartist = mpx.LastFMArtist(track[mpx.AttributeId.ARTIST].val().get_string())
                artist = lastfmartist.run()
                self.buf.insert(self.buf.get_end_iter(), artist)
            except:
                print "No Last.fm wiki" 

            if track[mpx.AttributeId.MB_TRACK_ID] and track[mpx.AttributeId.MB_TRACK_ID].is_initialized():
        
                trackId = track.get(mpx.AttributeId.MB_TRACK_ID).val().get_string()
                mbtrack = self.q.getTrackById(trackId, self.wsinc) 

                rels = mbtrack.getRelations()
                reldict = {}

                for rel in rels:
                    if rel.getDirection() != "backward":
                        x,y,reltype = rel.getType().partition("#")

                        try:
                            reldict[reltype].append(rel)
                        except:
                            reldict[reltype] = []
                            reldict[reltype].append(rel)

                funcdict = {"Cover":self.printCover,
                            "Composer":self.printComposer,
                            "Instrument":self.printInstrument,
                            "SamplesMaterial":self.printSamplesMaterial,
                            "Remixer":self.printRemixer,
                            "Lyricist":self.printLyricist,
                            "Producer":self.printProducer,
                            "Performer":self.printPerformer }

                self.entities = []
                self.link_tags = []

                if track[mpx.AttributeId.MB_ARTIST_ID].is_initialized():
                        self.entities.append(track[mpx.AttributeId.MB_ARTIST_ID].val().get_string())

                self.buf.insert(self.buf.get_end_iter(), "\n\n")

                self.buf.insert_with_tags(self.buf.get_end_iter(), "This Track", self.textTagLarge, self.textTagUnderline)
                self.buf.insert(self.buf.get_end_iter(), "\n")
                for rel in reldict:
                    if rel in funcdict:
                        rellist = reldict[rel]
                        funcdict[rel](rellist)
                        #for relitem in rellist:
                        #    funcdict[rel](relitem)
                self.buf.insert(self.buf.get_end_iter(), "\n\n")

                if track[mpx.AttributeId.MB_ALBUM_ID] and track[mpx.AttributeId.MB_ALBUM_ID].is_initialized(): 
                    entity = self.q.getReleaseById(track[mpx.AttributeId.MB_ALBUM_ID].val().get_string(), self.wsinc_release)
                    rels = entity.getRelations()
                    self.buf.insert_with_tags(self.buf.get_end_iter(), "Album Links", self.textTagUnderline, self.textTagLarge)
                    self.buf.insert(self.buf.get_end_iter(), "\n")
                    self.display_relations (rels)
                    self.buf.insert(self.buf.get_end_iter(), "\n\n")

                self.buf.insert_with_tags(self.buf.get_end_iter(), "Contributor Links", self.textTagUnderline, self.textTagLarge)
                self.buf.insert(self.buf.get_end_iter(), "\n")
                self.entities = dict(zip(self.entities,self.entities)).keys() 
                for ent in self.entities:
                    entity = self.q.getArtistById(ent, self.wsinc)   
                    self.buf.insert_with_tags(self.buf.get_end_iter(), entity.getName(), self.textTagBold)
                    self.buf.insert(self.buf.get_end_iter(), ": ")
                    rels = entity.getRelations()
                    self.display_relations (rels)
                    self.buf.insert(self.buf.get_end_iter(), "\n")

                self.Done = True
                #exit()

        except musicbrainz2.webservice.WebServiceError:
           
            self.Done = True 
            #exit()

    def display_relations(self, rels): 

            translit = {"Discogs":"Discogs Link", "Wikipedia":"Wikipedia Link", "Myspace":"Myspace Website", "OfficialHomepage":"Band Homepage"}
            ar = {}

            for rel in rels:

                mbns, hash, reltype = rel.getType().partition("#")
                try:
                    ar[reltype].append(rel)
                except:
                    ar[reltype] = []
                    ar[reltype].append(rel)

            for a in ar:

                if a in translit: 

                    rls = ar[a]
                    for rel in rls:
                        link_tag = LinkTag(rel.getTargetId()) 
                        link_tag.connect("url-clicked", self.on_url_clicked)
                        self.buf.get_tag_table().add(link_tag)
                        self.buf.insert_with_tags(self.buf.get_end_iter(), translit[a], link_tag) 
                        if len(rls) > 1:
                            self.buf.insert(self.buf.get_end_iter(), "(" + str(rls.index(rel)+1) + ")") 
                        self.buf.insert(self.buf.get_end_iter(), "  ")

    def on_url_clicked(self, obj, url):
        
        command = "xdg-open \"%s\"" % url
        os.system(command)

    def printCover(self, rels):

        for rel in rels:

            # Workaround for buggy pymusicbrainzl; getTarget() on this rel returns None
            url = rel.getTargetId()
            id = url[url.rindex("/")+1:]
            cover = self.q.getTrackById(id, self.wsinc)  
            coverartist = cover.getArtist()

            self.buf.insert_with_tags(self.buf.get_end_iter(), "...is a cover of ")
            self.buf.insert_with_tags(self.buf.get_end_iter(), cover.getTitle(), self.textTagBold)
            self.buf.insert_with_tags(self.buf.get_end_iter(), " by ")
            self.buf.insert_with_tags(self.buf.get_end_iter(), coverartist.getName(), self.textTagBold)
            self.buf.insert_with_tags(self.buf.get_end_iter(), "")
            self.buf.insert(self.buf.get_end_iter(), "\n") 

        return True

    def printComposer(self, rels):

        self.buf.insert_with_tags(self.buf.get_end_iter(), "...was composed by ")

        composers = []

        for rel in rels:
            composer = rel.getTarget()
            self.entities.append(rel.getTargetId())
            composers.append(composer.getName())
        
        self.buf.insert_with_tags(self.buf.get_end_iter(), ", ".join(composers), self.textTagBold) 
        self.buf.insert(self.buf.get_end_iter(), "\n") 
        return True

    def printSamplesMaterial(self, rels):

        sampled = []

        for rel in rels:
            url = rel.getTargetId()
            id = url[url.rindex("/")+1:]
            trk = self.q.getTrackById(id, self.wsinc)
            sampledartist = trk.getArtist()
            self.entities.append(rel.getArtistId())
            sampled.append(trk.getTitle() + " by " + sampledartist.getName())

        self.buf.insert_with_tags(self.buf.get_end_iter(), "...contains samples from ")
        self.buf.insert_with_tags(self.buf.get_end_iter(), ", ".join(sampled), self.textTagBold) 
        self.buf.insert(self.buf.get_end_iter(), "\n") 
        return True

    def printRemixer(self, rels):

        remixers = []

        for rel in rels:
            url = rel.getTargetId()
            id = url[url.rindex("/")+1:]
            remixer = self.q.getArtistById(id, self.wsinc)
            self.entities.append(id)
            remixers.append(remixer.getName())

        self.buf.insert_with_tags(self.buf.get_end_iter(), "...was remixed by ")
        self.buf.insert_with_tags(self.buf.get_end_iter(), ", ".join(remixers), self.textTagBold) 
        self.buf.insert(self.buf.get_end_iter(), "\n") 
        return True

    def printProducer(self, rels):

        producers = []

        for rel in rels:
            url = rel.getTargetId()
            id = url[url.rindex("/")+1:]
            producer = self.q.getArtistById(id, self.wsinc)
            self.entities.append(id)
            producers.append(producer.getName())
            
        self.buf.insert_with_tags(self.buf.get_end_iter(), "...was produced by ")
        self.buf.insert_with_tags(self.buf.get_end_iter(), ", ".join(producers), self.textTagBold) 
        self.buf.insert(self.buf.get_end_iter(), "\n") 
        return True

    def printLyricist(self, rels):

        lyricists = []

        for rel in rels:
            lyricist = rel.getTarget() 
            self.entities.append(rel.getTargetId())
            lyricists.append(lyricist.getName())

        self.buf.insert_with_tags(self.buf.get_end_iter(), "...has lyrics by ")
        self.buf.insert_with_tags(self.buf.get_end_iter(), ", ".join(lyricists), self.textTagBold) 
        self.buf.insert(self.buf.get_end_iter(), "\n") 
        return True

    def printProducer(self, rels):

        producers = []

        for rel in rels:
            producer = rel.getTarget() 
            self.entities.append(rel.getTargetId())
            producers.append(producer.getName())

        self.buf.insert_with_tags(self.buf.get_end_iter(), "...was produced by ")
        self.buf.insert_with_tags(self.buf.get_end_iter(), ", ".join(producers), self.textTagBold) 
        self.buf.insert(self.buf.get_end_iter(), "\n") 
        return True

    def printPerformer(self, rels):

        performers = []

        for rel in rels:
            performer = rel.getTarget() 
            self.entities.append(rel.getTargetId())
            performers.append(performer.getName())

        self.buf.insert_with_tags(self.buf.get_end_iter(), "...was performed by ")
        self.buf.insert_with_tags(self.buf.get_end_iter(), ", ".join(performers), self.textTagBold) 
        self.buf.insert(self.buf.get_end_iter(), "\n") 
        return True

    def printInstrument(self, rels):
        return True

class TrackInfoDispatcher(mpx.Plugin):

    def __init__(self):

        self.xml = gtk.glade.XML("@DATA_DIR@" + "/python-plugins/trackinfo/trackinfo.glade")
        self.notebook = self.xml.get_widget("notebook-track-info-1")

    def activate(self,player,mcs):
        self.player = player
        self.player_infoarea_click_id = self.player.gobj().connect("infoarea-click", self.new_track)
        self.player_playstatus_changed_id = self.player.gobj().connect("play-status-changed", self.pstate_changed)
        self.info = TrackInfo(self.xml)
        self.player.add_info_widget(self.notebook, "Track Info")
        self.notebook.show_all()
        return True

    def deactivate(self):
        self.player.gobj().disconnect(self.player_infoarea_click_id)
        self.player.gobj().disconnect(self.player_playstatus_changed_id)
        self.player = None
        self.info = None

    def pstate_changed(self, blah, state):

        if state == mpx.PlayStatus.STOPPED:
            self.info.clear()

    def new_track(self, blah):
        m = self.player.get_metadata()
        self.info.run(m)


