
# -*- coding: utf-8 -*-
# -*- mode:python ; tab-width:4 -*- ex:set tabstop=4 shiftwidth=4 expandtab: -*-
#
# MPX Trackinfo
# (C) 2008 M. Derezynski
#

import mpx
import pygtk
pygtk.require('2.0')
import gtk
import gtk.glade
import gobject
import pygst
pygst.require('0.10')
import gst
import pango
import time
import os
import musicbrainz2
import musicbrainz2.webservice as ws

class WaitSecond:

        def __init__(self):

                self.initialtime = time.time()

        def waitsecond(self):

                return        
                t = time.time() # Only to do something in the loop
                while (t - self.initialtime) < 2: 
                        t = time.time()

                self.initialtime = time.time()

class LinkTag(gtk.TextTag):

    __gsignals__ = {
            'url-clicked' : (gobject.SIGNAL_RUN_LAST, gobject.TYPE_NONE,
                (gobject.TYPE_STRING,))
        }

    def __init__(self, link):

        gtk.TextTag.__init__(self)
        self.set_property("foreground", "#0000ff")
        self.link = link

    def do_event(self, event_obj, event, iter):     

        if event.type == gtk.gdk.BUTTON_PRESS:
             if event.button == 1:
                self.emit("url-clicked", self.link)

    def get_url(self):

        return self.link

class TrackInfo:

    def __init__(self, xml):

        self.wait = WaitSecond()
        self.q = ws.Query(musicbrainz2.webservice.WebService("www.uk.musicbrainz.org"))
        self.wsinc = musicbrainz2.webservice.TrackIncludes(trackRelations=True,artist=True,puids=True,releases=True,artistRelations=True,releaseRelations=True,urlRelations=True)
        self.wsinc_release = musicbrainz2.webservice.ReleaseIncludes(releaseEvents=True,releaseRelations=True,urlRelations=True)

        self.xml = xml
        self.notebook = self.xml.get_widget("notebook-track-info-1")
        self.progress = self.xml.get_widget("progress")
        self.textview = self.xml.get_widget("textview")
        self.textview.connect("motion-notify-event", self.on_view_motion_notify)
        self.throb = self.xml.get_widget("throb")
        self.throb.set_from_file("@DATA_DIR@" + "/images/throbber.gif")
        self.notebook.set_current_page(0)

        self.buf = self.textview.get_buffer()

        self.textTagBold = gtk.TextTag()
        self.textTagBold.set_property("weight", pango.WEIGHT_BOLD)
        self.buf.get_tag_table().add(self.textTagBold)
        
        self.textTagCenter = gtk.TextTag()
        self.textTagCenter.set_property("justification", gtk.JUSTIFY_CENTER) 
        self.buf.get_tag_table().add(self.textTagCenter)

        self.textTagLarge = gtk.TextTag()
        self.textTagLarge.set_property("size-points", 16) 
        self.buf.get_tag_table().add(self.textTagLarge)

        self.textTagSlant = gtk.TextTag()
        self.textTagSlant.set_property("style", pango.STYLE_ITALIC) 
        self.buf.get_tag_table().add(self.textTagSlant)

        self.textTagUnderline = gtk.TextTag()
        self.textTagUnderline.set_property("underline", pango.UNDERLINE_SINGLE) 
        self.textTagUnderline.set_property("weight", pango.WEIGHT_BOLD)
        self.buf.get_tag_table().add(self.textTagUnderline)

        self.Hand = False
        self.player = gst.Pipeline("player")
        self.source = gst.element_factory_make("giosrc", "file-source")
        self.player.add(self.source)
        self.demuxer = gst.element_factory_make("decodebin", "demuxer")
        self.player.add(self.demuxer)
        self.demuxer.connect("new-decoded-pad", self.demuxer_callback)
        self.puid = gst.element_factory_make("puid", "puid")
        self.player.add(self.puid)
        self.gotPuid = False
        self.puid.set_property('musicdns-id', '234e8289d5a5fd4b29127bd114309954')
        self.audiosink = gst.element_factory_make("fakesink", "audio-output")
        self.player.add(self.audiosink)
        gst.element_link_many(self.source, self.demuxer)
        gst.element_link_many(self.puid, self.audiosink)
        self.bus = self.player.get_bus()
        self.bus.add_signal_watch()
        self.bus.connect('message', self.on_message)

    def demuxer_callback(self, demuxer, pad, arg):

        dec_pad = self.puid.get_pad("sink")
        pad.link(dec_pad)
    
    def display_pipeline_duration(self):

        position, format = self.player.query_position(gst.FORMAT_TIME)
        frac = float(position) / float(135000000000)
        if (frac >= 0.) and (frac <= 1.0): 
            self.progress.set_fraction(frac)

        if self.gotPuid:
            self.progress.set_fraction(0.)
            self.progress.hide()
            return False
        else:
            return True

    def on_message(self, bus, message):    

        t = message.type
        if t == gst.MESSAGE_EOS:
            puid = self.puid.get_property('puid')
            if puid and len(puid) > 0:
                result = ws.TrackFilter(puid=puid) 
                tracks = self.q.getTracks(result)

                if len(tracks) > 0:

                    self.track[mpx.AttributeId.MB_TRACK_ID].set_string(str(tracks[0].getTrack().getId()))

                    mbtrack = self.q.getTrackById(tracks[0].getTrack().getId(), self.wsinc) 
                    artist = mbtrack.getArtist()

                    self.track[mpx.AttributeId.MB_ARTIST_ID].set_string(str(artist.getId()))

                    if not self.track[mpx.AttributeId.ARTIST]:
                        self.track[mpx.AttributeId.ARTIST].set_string(str(artist.getName()))
                    
                    if not self.track[mpx.AttributeId.TITLE]:
                        self.track[mpx.AttributeId.TITLE].set_string(str(mbtrack.getTitle()))

            self.gotPuid = True
            self.show_real()
    
    def clear(self):

        self.buf.set_text('')

    def on_view_motion_notify(self, widget, event):

        if event.is_hint: 

            x, y, state = event.window.get_pointer()
        
        else:

            x = event.x
            y = event.y
            state = event.state

        xb, yb = self.textview.window_to_buffer_coords(gtk.TEXT_WINDOW_WIDGET, x, y)
        iter = self.textview.get_iter_at_location(xb, yb)
        tags = iter.get_tags() 


        for tag in tags:
            if isinstance(tag, LinkTag):

                cursor = gtk.gdk.cursor_new_from_name(gtk.gdk.display_get_default(), "hand2")
                window = self.textview.get_window(gtk.TEXT_WINDOW_TEXT)                
                window.set_cursor(cursor)

                self.Hand = True

                self.textview.set_property("has-tooltip", True)
                self.textview.set_tooltip_text(tag.get_url())

                return False


        if self.Hand:

            cursor = gtk.gdk.cursor_new_from_name(gtk.gdk.display_get_default(), "xterm")
            window = self.textview.get_window(gtk.TEXT_WINDOW_TEXT)                
            window.set_cursor(cursor)

            self.Hand = False

            self.textview.set_property("has-tooltip", False)

        return False

    def run(self,track):

        self.notebook.set_current_page(1)
        self.track = track
        self.show()

    def show(self):

        track = self.track

        if not self.gotPuid and not track[mpx.AttributeId.MB_TRACK_ID] and track.get(mpx.AttributeId.LOCATION).get()[:7] == "file://":

            self.player.get_by_name("file-source").set_property('location', track.get(mpx.AttributeId.LOCATION).get())
            self.player.set_state(gst.STATE_PLAYING)
            
            gobject.timeout_add (500, self.display_pipeline_duration)
            self.progress.show_all() 

            while not self.gotPuid: 
                while gtk.events_pending():
                    gtk.main_iteration()

            self.gotPuid = False

        else:

            self.show_real()

    def show_real(self):

        track = self.track

        try:
            self.buf.delete(self.buf.get_start_iter(), self.buf.get_end_iter())
            self.buf.insert(self.buf.get_end_iter(), "\n\n\n")

            try:
                lastfmartist = mpx.LastFMArtist(track[mpx.AttributeId.ARTIST].get())
                artist = lastfmartist.run()
                self.buf.insert_with_tags(self.buf.get_end_iter(), "About " + track[mpx.AttributeId.ARTIST].get() + "\n", self.textTagLarge, self.textTagUnderline)
                self.buf.insert(self.buf.get_end_iter(), artist)
                self.buf.insert(self.buf.get_end_iter(), "\n\n")
            except:
                pass 
        
            try:
                lyricwiki = mpx.LyricWiki(track[mpx.AttributeId.ARTIST].get(), track[mpx.AttributeId.TITLE].get())
                lyrics = lyricwiki.run()
                if lyrics != "Not found":
                    self.buf.insert_with_tags(self.buf.get_end_iter(), "Lyrics\n", self.textTagLarge, self.textTagUnderline)
                    self.buf.insert(self.buf.get_end_iter(), lyrics)
                    self.buf.insert(self.buf.get_end_iter(), "\n\n\n")
            except:
                pass 

            if track[mpx.AttributeId.MB_TRACK_ID] and track[mpx.AttributeId.MB_TRACK_ID]:
        
                trackId = track.get(mpx.AttributeId.MB_TRACK_ID).get()
                mbtrack = self.q.getTrackById(trackId, self.wsinc) 

                rels = mbtrack.getRelations()
                reldict = {}

                for rel in rels:
                    if rel.getDirection() != "backward":
                        x,y,reltype = rel.getType().partition("#")

                        try:
                            reldict[reltype].append(rel)
                        except:
                            reldict[reltype] = []
                            reldict[reltype].append(rel)

                funcdict = {"Cover":self.printCover,
                            "Composer":self.printComposer,
                            "Instrument":self.printInstrument,
                            "SamplesMaterial":self.printSamplesMaterial,
                            "Remixer":self.printRemixer,
                            "Lyricist":self.printLyricist,
                            "Producer":self.printProducer,
                            "Performer":self.printPerformer }

                self.entities = []
                self.link_tags = []

                if track[mpx.AttributeId.MB_ARTIST_ID]:
                        self.entities.append(track[mpx.AttributeId.MB_ARTIST_ID].get())

                rellists = []
                for rel in reldict:
                    if rel in funcdict:
                        rellists.append(reldict[rel])

                if len(rellists) > 0:
                    self.buf.insert_with_tags(self.buf.get_end_iter(), "This Track\n", self.textTagLarge, self.textTagUnderline)
                    for rellist in rellists:
                        funcdict[rel](rellist)
                    self.buf.insert(self.buf.get_end_iter(), "\n\n\n")

                if track[mpx.AttributeId.MB_ALBUM_ID] and track[mpx.AttributeId.MB_ALBUM_ID]: 
                    entity = self.q.getReleaseById(track[mpx.AttributeId.MB_ALBUM_ID].get(), self.wsinc_release)
                    rels = entity.getRelations()
                    if len(rels) > 0:
                        self.buf.insert_with_tags(self.buf.get_end_iter(), "Album Links\n", self.textTagLarge, self.textTagUnderline)
                        self.display_relations (rels)
                        self.buf.insert(self.buf.get_end_iter(), "\n\n\n")

                self.entities = dict(zip(self.entities,self.entities)).keys() 
                if len(self.entities) > 0:
                    self.buf.insert_with_tags(self.buf.get_end_iter(), "Contributor Links\n", self.textTagUnderline, self.textTagLarge)
                    for ent in self.entities:
                        entity = self.q.getArtistById(ent, self.wsinc)   
                        self.buf.insert_with_tags(self.buf.get_end_iter(), entity.getName(), self.textTagBold)
                        self.buf.insert(self.buf.get_end_iter(), ": ")
                        rels = entity.getRelations()
                        self.display_relations (rels)
        except:
        
            pass

        self.buf.insert(self.buf.get_end_iter(), "\n\n\n")
        self.notebook.set_current_page(2)

    def display_relations(self, rels): 

            translit = {"Discogs":"Discogs Link", "Wikipedia":"Wikipedia Link", "Myspace":"Myspace Website", "OfficialHomepage":"Band Homepage"}
            ar = {}

            for rel in rels:

                mbns, hash, reltype = rel.getType().partition("#")
                try:
                    ar[reltype].append(rel)
                except:
                    ar[reltype] = []
                    ar[reltype].append(rel)

            for a in ar:

                if a in translit: 

                    rls = ar[a]
                    for rel in rls:
                        link_tag = LinkTag(rel.getTargetId()) 
                        link_tag.connect("url-clicked", self.on_url_clicked)
                        self.buf.get_tag_table().add(link_tag)
                        self.buf.insert_with_tags(self.buf.get_end_iter(), translit[a], link_tag) 
                        if len(rls) > 1:
                            self.buf.insert(self.buf.get_end_iter(), "(" + str(rls.index(rel)+1) + ")") 
                        self.buf.insert(self.buf.get_end_iter(), "  ")

    def on_url_clicked(self, obj, url):
        
        command = "xdg-open \"%s\"" % url
        os.system(command)

    def printCover(self, rels):

        for rel in rels:

            # Workaround for buggy pymusicbrainzl; getTarget() on this rel returns None
            url = rel.getTargetId()
            id = url[url.rindex("/")+1:]
            cover = self.q.getTrackById(id, self.wsinc)  
            coverartist = cover.getArtist()

            self.buf.insert_with_tags(self.buf.get_end_iter(), "...is a cover of ")
            self.buf.insert_with_tags(self.buf.get_end_iter(), cover.getTitle(), self.textTagBold)
            self.buf.insert_with_tags(self.buf.get_end_iter(), " by ")
            self.buf.insert_with_tags(self.buf.get_end_iter(), coverartist.getName(), self.textTagBold)
            self.buf.insert_with_tags(self.buf.get_end_iter(), "")
            self.buf.insert(self.buf.get_end_iter(), "\n") 

        return True

    def printComposer(self, rels):

        self.buf.insert_with_tags(self.buf.get_end_iter(), "...was composed by ")

        composers = []

        for rel in rels:
            composer = rel.getTarget()
            self.entities.append(rel.getTargetId())
            composers.append(composer.getName())
        
        self.buf.insert_with_tags(self.buf.get_end_iter(), ", ".join(composers), self.textTagBold) 
        self.buf.insert(self.buf.get_end_iter(), "\n") 
        return True

    def printSamplesMaterial(self, rels):

        sampled = []

        for rel in rels:
            url = rel.getTargetId()
            id = url[url.rindex("/")+1:]
            trk = self.q.getTrackById(id, self.wsinc)
            sampledartist = trk.getArtist()
            self.entities.append(rel.getArtistId())
            sampled.append(trk.getTitle() + " by " + sampledartist.getName())

        self.buf.insert_with_tags(self.buf.get_end_iter(), "...contains samples from ")
        self.buf.insert_with_tags(self.buf.get_end_iter(), ", ".join(sampled), self.textTagBold) 
        self.buf.insert(self.buf.get_end_iter(), "\n") 
        return True

    def printRemixer(self, rels):

        remixers = []

        for rel in rels:
            url = rel.getTargetId()
            id = url[url.rindex("/")+1:]
            remixer = self.q.getArtistById(id, self.wsinc)
            self.entities.append(id)
            remixers.append(remixer.getName())

        self.buf.insert_with_tags(self.buf.get_end_iter(), "...was remixed by ")
        self.buf.insert_with_tags(self.buf.get_end_iter(), ", ".join(remixers), self.textTagBold) 
        self.buf.insert(self.buf.get_end_iter(), "\n") 
        return True

    def printProducer(self, rels):

        producers = []

        for rel in rels:
            url = rel.getTargetId()
            id = url[url.rindex("/")+1:]
            producer = self.q.getArtistById(id, self.wsinc)
            self.entities.append(id)
            producers.append(producer.getName())
            
        self.buf.insert_with_tags(self.buf.get_end_iter(), "...was produced by ")
        self.buf.insert_with_tags(self.buf.get_end_iter(), ", ".join(producers), self.textTagBold) 
        self.buf.insert(self.buf.get_end_iter(), "\n") 
        return True

    def printLyricist(self, rels):

        lyricists = []

        for rel in rels:
            lyricist = rel.getTarget() 
            self.entities.append(rel.getTargetId())
            lyricists.append(lyricist.getName())

        self.buf.insert_with_tags(self.buf.get_end_iter(), "...has lyrics by ")
        self.buf.insert_with_tags(self.buf.get_end_iter(), ", ".join(lyricists), self.textTagBold) 
        self.buf.insert(self.buf.get_end_iter(), "\n") 
        return True

    def printProducer(self, rels):

        producers = []

        for rel in rels:
            producer = rel.getTarget() 
            self.entities.append(rel.getTargetId())
            producers.append(producer.getName())

        self.buf.insert_with_tags(self.buf.get_end_iter(), "...was produced by ")
        self.buf.insert_with_tags(self.buf.get_end_iter(), ", ".join(producers), self.textTagBold) 
        self.buf.insert(self.buf.get_end_iter(), "\n") 
        return True

    def printPerformer(self, rels):

        performers = []

        for rel in rels:
            performer = rel.getTarget() 
            self.entities.append(rel.getTargetId())
            performers.append(performer.getName())

        self.buf.insert_with_tags(self.buf.get_end_iter(), "...was performed by ")
        self.buf.insert_with_tags(self.buf.get_end_iter(), ", ".join(performers), self.textTagBold) 
        self.buf.insert(self.buf.get_end_iter(), "\n") 
        return True

    def printInstrument(self, rels):
        return True

class TrackInfoDispatcher(mpx.Plugin):

    """The Trackinfo Plugin provides a Last.fm/Musicbrainz based track info for the currently played track."""

    def __init__(self,id,player,mcs):
    
        self.id = id
        self.player = player
        self.xml = gtk.glade.XML("@DATA_DIR@" + "/python-plugins/trackinfo/trackinfo.glade")
        self.vbox = self.xml.get_widget("vbox")
        self.vbox.unparent()
        self.notebook = self.xml.get_widget("notebook-track-info-1")

    def activate(self):

        self.player_infoarea_click_id = self.player.gobj().connect("infoarea-click", self.new_track)
        self.player_playstatus_changed_id = self.player.gobj().connect("play-status-changed", self.pstate_changed)
        self.info = TrackInfo(self.xml)
        self.player.add_info_widget(self.vbox, "Track Info")
        self.notebook.show_all()
        return True

    def deactivate(self):
        self.player.remove_info_widget(self.vbox)
        self.player.gobj().disconnect(self.player_infoarea_click_id)
        self.player.gobj().disconnect(self.player_playstatus_changed_id)
        self.info = None

    def pstate_changed(self, blah, state):

        if state == mpx.PlayStatus.STOPPED:
            self.info.clear()

    def new_track(self, blah):
        try:
            m = self.player.get_metadata()
            self.info.run(m)
        except:
            return

