
# MPX Trackinfo
# (C) 2008 M. Derezynski
#

import mpx
import pygtk
pygtk.require('2.0')
import gtk
import gtk.glade
import gobject
import pango
import time
import os
import thread
import musicbrainz2
import musicbrainz2.webservice as ws

class WaitSecond:

        def __init__(self):

                self.initialtime = time.time()

        def waitsecond(self):

                return        
                t = time.time() # Only to do something in the loop
                while (t - self.initialtime) < 2: 
                        t = time.time()

                self.initialtime = time.time()

class LinkTag(gtk.TextTag):

    __gsignals__ = {
            'url-clicked' : (gobject.SIGNAL_RUN_LAST, gobject.TYPE_NONE,
                (gobject.TYPE_STRING,))
        }

    def __init__(self, link):

        gtk.TextTag.__init__(self)
        self.set_property("foreground", "#0000ff")
        self.link = link

    def do_event(self, event_obj, event, iter):     

        if event.type == gtk.gdk.BUTTON_PRESS:
             if event.button == 1:
                self.emit("url-clicked", self.link)

class TrackInfo:

    def __init__(self, xml):

        self.wait = WaitSecond()
        self.q = ws.Query(musicbrainz2.webservice.WebService("www.uk.musicbrainz.org"))
        self.wsinc = musicbrainz2.webservice.TrackIncludes(trackRelations=True,artist=True,puids=True,releases=True,artistRelations=True,releaseRelations=True,urlRelations=True)
        self.wsinc_release = musicbrainz2.webservice.ReleaseIncludes(releaseEvents=True,releaseRelations=True,urlRelations=True)

        self.xml = xml
        self.notebook = self.xml.get_widget("notebook-track-info-1")
        self.textview = self.xml.get_widget("textview")
        self.textview.connect("motion-notify-event", self.on_view_motion_notify)
        self.throb = self.xml.get_widget("throb")
        self.throb.set_from_file("@DATA_DIR@" + "/images/throbber.gif")
        self.notebook.set_current_page(0)

        self.buf = self.textview.get_buffer()

        self.textTagBold = gtk.TextTag()
        self.textTagBold.set_property("weight", pango.WEIGHT_BOLD)
        self.buf.get_tag_table().add(self.textTagBold)
        
        self.textTagCenter = gtk.TextTag()
        self.textTagCenter.set_property("justification", gtk.JUSTIFY_CENTER) 
        self.buf.get_tag_table().add(self.textTagCenter)

        self.textTagLarge = gtk.TextTag()
        self.textTagLarge.set_property("size-points", 16) 
        self.buf.get_tag_table().add(self.textTagLarge)

        self.textTagSlant = gtk.TextTag()
        self.textTagSlant.set_property("style", pango.STYLE_ITALIC) 
        self.buf.get_tag_table().add(self.textTagSlant)

        self.textTagUnderline = gtk.TextTag()
        self.textTagUnderline.set_property("underline", pango.UNDERLINE_SINGLE) 
        self.buf.get_tag_table().add(self.textTagUnderline)

        self.Hand = False

    def on_view_motion_notify(self, widget, event):

        if event.is_hint: 

            x, y, state = event.window.get_pointer()
        
        else:

            x = event.x
            y = event.y
            state = event.state

        xb, yb = self.textview.window_to_buffer_coords(gtk.TEXT_WINDOW_WIDGET, x, y)
        iter = self.textview.get_iter_at_location(xb, yb)
        tags = iter.get_tags() 

        for tag in tags:

            if isinstance(tag, LinkTag):
                window = self.textview.get_window(gtk.TEXT_WINDOW_TEXT)                
                cursor = gtk.gdk.cursor_new_from_name(gtk.gdk.display_get_default(), "hand2")
                window.set_cursor(cursor)
                self.Hand = True
                return False

        if self.Hand:

            window = self.textview.get_window(gtk.TEXT_WINDOW_TEXT)                
            cursor = gtk.gdk.cursor_new_from_name(gtk.gdk.display_get_default(), "xterm")
            window.set_cursor(cursor)
            self.Hand = False

        return False

    def run(self,track):

        self.notebook.set_current_page(1)

        self.track = track
        self.Done = False
        self.show([])
        #self.thread = thread.start_new_thread(self.show, (self,))

        #while not self.Done:
        #        while gtk.events_pending():
        #                gtk.main_iteration()

        self.notebook.set_current_page(2)

    def show(self, blah):

        try:
            track = self.track
            self.buf.delete(self.buf.get_start_iter(), self.buf.get_end_iter())
            self.buf.insert(self.buf.get_end_iter(), "\n")

            try:
                self.buf.insert_with_tags(self.buf.get_end_iter(), "Lyrics", self.textTagLarge)
                self.buf.insert(self.buf.get_end_iter(), "\n\n")
                lyricwiki = mpx.LyricWiki(track[mpx.AttributeId.ARTIST].val().get_string(), track[mpx.AttributeId.TITLE].val().get_string())
                lyrics = lyricwiki.run()
                self.buf.insert(self.buf.get_end_iter(), lyrics)
            except:
                print "Couldn't get lyrics for '" + track[mpx.AttributeId.ARTIST].val().get_string() + " / " +  track[mpx.AttributeId.TITLE].val().get_string()+ "'"
            
            try:
                self.buf.insert(self.buf.get_end_iter(), "\n\n")
                self.buf.insert_with_tags(self.buf.get_end_iter(), "About " + track[mpx.AttributeId.ARTIST].val().get_string(), self.textTagLarge)
                self.buf.insert(self.buf.get_end_iter(), "\n\n")
                lastfmartist = mpx.LastFMArtist(track[mpx.AttributeId.ARTIST].val().get_string())
                artist = lastfmartist.run()
                self.buf.insert(self.buf.get_end_iter(), artist)
            except:
                print "Couldn't get Last.fm artist info for '" + track[mpx.AttributeId.ARTIST].val().get_string() 

            try:
                trackId = track.get(mpx.AttributeId.MB_TRACK_ID).val().get_string()
                mbtrack = self.q.getTrackById(trackId, self.wsinc) 

                rels = mbtrack.getRelations()
                reldict = {}

                for rel in rels:
                    if rel.getDirection() != "backward":
                        x,y,reltype = rel.getType().partition("#")

                        try:
                            reldict[reltype].append(rel)
                        except:
                            reldict[reltype] = []
                            reldict[reltype].append(rel)

                funcdict = {"Cover":self.printCover,
                            "Composer":self.printComposer,
                            "Instrument":self.printInstrument,
                            "SamplesMaterial":self.printSamplesMaterial,
                            "Remixer":self.printRemixer,
                            "Lyricist":self.printLyricist,
                            "Producer":self.printProducer }

                self.entities = []
                self.link_tags = []

                if track[mpx.AttributeId.MB_ARTIST_ID].is_initialized():
                        self.entities.append(track[mpx.AttributeId.MB_ARTIST_ID].val().get_string())

                self.buf.insert(self.buf.get_end_iter(), "\n\n")

                self.buf.insert_with_tags(self.buf.get_end_iter(), "This Track", self.textTagUnderline, self.textTagLarge)
                self.buf.insert(self.buf.get_end_iter(), "\n")
                for rel in reldict:
                    if rel in funcdict:
                        rellist = reldict[rel]
                        for relitem in rellist:
                            funcdict[rel](relitem)
                self.buf.insert(self.buf.get_end_iter(), "\n\n")

                self.buf.insert_with_tags(self.buf.get_end_iter(), "Album Links", self.textTagUnderline, self.textTagLarge)
                self.buf.insert(self.buf.get_end_iter(), "\n")
                entity = self.q.getReleaseById(track[mpx.AttributeId.MB_ALBUM_ID].val().get_string(), self.wsinc_release)
                rels = entity.getRelations()
                self.display_relations (rels)
                self.buf.insert(self.buf.get_end_iter(), "\n\n")

                self.buf.insert_with_tags(self.buf.get_end_iter(), "Contributor Links", self.textTagUnderline, self.textTagLarge)
                self.buf.insert(self.buf.get_end_iter(), "\n")
                self.entities = dict(zip(self.entities,self.entities)).keys() 
                for ent in self.entities:
                    entity = self.q.getArtistById(ent, self.wsinc)   
                    self.buf.insert_with_tags(self.buf.get_end_iter(), entity.getName(), self.textTagBold)
                    self.buf.insert(self.buf.get_end_iter(), ": ")
                    rels = entity.getRelations()
                    self.display_relations (rels)
                    self.buf.insert(self.buf.get_end_iter(), "\n")
            except:
                print "No Track ID"

            self.Done = True
            #exit()

        except musicbrainz2.webservice.WebServiceError:
            
            self.Done = True 
            #exit()

    def display_relations(self, rels): 

            translit = {"Discogs":"Discogs Link", "Wikipedia":"Wikipedia Link", "Myspace":"Myspace Website", "OfficialHomepage":"Band Homepage"}
            ar = {}

            for rel in rels:

                mbns, hash, reltype = rel.getType().partition("#")
                try:
                    ar[reltype].append(rel)
                except:
                    ar[reltype] = []
                    ar[reltype].append(rel)

            for a in ar:

                if a in translit: 

                    rls = ar[a]
                    for rel in rls:
                        link_tag = LinkTag(rel.getTargetId()) 
                        link_tag.connect("url-clicked", self.on_url_clicked)
                        self.buf.get_tag_table().add(link_tag)
                        self.buf.insert_with_tags(self.buf.get_end_iter(), translit[a], link_tag) 
                        if len(rls) > 1:
                            self.buf.insert(self.buf.get_end_iter(), "(" + str(rls.index(rel)+1) + ")") 
                        self.buf.insert(self.buf.get_end_iter(), "  ")

    def on_url_clicked(self, obj, url):
        
        command = "xdg-open \"%s\"" % url
        os.system(command)

    def printCover(self, track, mbtrack, rels):

        for rel in rels:

            # Workaround for buggy pymusicbrainzl; getTarget() on this rel returns None
            url = rel.getTargetId()
            id = url[url.rindex("/")+1:]
            cover = self.q.getTrackById(id, self.wsinc)  
            coverartist = cover.getArtist()

            self.buf.insert_with_tags(self.buf.get_end_iter(), "...is a cover of ")
            self.buf.insert_with_tags(self.buf.get_end_iter(), cover.getTitle(), self.textTagBold)
            self.buf.insert_with_tags(self.buf.get_end_iter(), " by ")
            self.buf.insert_with_tags(self.buf.get_end_iter(), coverartist.getName(), self.textTagBold)
            self.buf.insert_with_tags(self.buf.get_end_iter(), "")
            self.buf.insert(self.buf.get_end_iter(), "\n") 

        return True

    def printComposer(self, track, mbtrack, rels):

        self.buf.insert_with_tags(self.buf.get_end_iter(), "...was composed by ")

        composers = []

        for rel in rels:
            composer = rel.getTarget()
            self.entities.append(rel.getTargetId())
            composers.append(composer.getName())
        
        self.buf.insert_with_tags(self.buf.get_end_iter(), ", ".join(composers), self.textTagBold) 
        self.buf.insert(self.buf.get_end_iter(), "\n") 
        return True

    def printSamplesMaterial(self, track, mbtrack, rels):

        sampled = []

        for rel in rels:
            url = rel.getTargetId()
            id = url[url.rindex("/")+1:]
            trk = self.q.getTrackById(id, self.wsinc)
            sampledartist = trk.getArtist()
            self.entities.append(rel.getArtistId())
            sampled.append(trk.getTitle() + " by " + sampledartist.getName())

        self.buf.insert_with_tags(self.buf.get_end_iter(), "...contains samples from ")
        self.buf.insert_with_tags(self.buf.get_end_iter(), ", ".join(sampled), self.textTagBold) 
        self.buf.insert(self.buf.get_end_iter(), "\n") 
        return True

    def printRemixer(self, track, mbtrack, rels):

        remixers = []

        for rel in rels:
            url = rel.getTargetId()
            id = url[url.rindex("/")+1:]
            remixer = self.q.getArtistById(id, self.wsinc)
            self.entities.append(id)
            remixers.append(remixer.getName())

        self.buf.insert_with_tags(self.buf.get_end_iter(), "...was remixed by ")
        self.buf.insert_with_tags(self.buf.get_end_iter(), ", ".join(remixers), self.textTagBold) 
        self.buf.insert(self.buf.get_end_iter(), "\n") 
        return True

    def printProducer(self, track, mbtrack, rels):

        producers = []

        for rel in rels:
            url = rel.getTargetId()
            id = url[url.rindex("/")+1:]
            producer = self.q.getArtistById(id, self.wsinc)
            self.entities.append(id)
            producers.append(producer.getName())
            
        self.buf.insert_with_tags(self.buf.get_end_iter(), "...was produced by ")
        self.buf.insert_with_tags(self.buf.get_end_iter(), ", ".join(producers), self.textTagBold) 
        self.buf.insert(self.buf.get_end_iter(), "\n") 
        return True

    def printLyricist(self, track, mbtrack, rels):

        lyricists = []

        for rel in rels:
            lyricist = rel.getTarget() 
            self.entities.append(rel.getTargetId())
            lyricists.append(lyricist.getName())

        self.buf.insert_with_tags(self.buf.get_end_iter(), "...has lyrics by ")
        self.buf.insert_with_tags(self.buf.get_end_iter(), ", ".join(lyricists), self.textTagBold) 
        self.buf.insert(self.buf.get_end_iter(), "\n") 
        return True

    def printProducer(self, track, mbtrack, rels):

        producers = []

        for rel in rels:
            producer = rel.getTarget() 
            self.entities.append(rel.getTargetId())
            producers.append(producer.getName())

        self.buf.insert_with_tags(self.buf.get_end_iter(), "...was produced by ")
        self.buf.insert_with_tags(self.buf.get_end_iter(), ", ".join(producers), self.textTagBold) 
        self.buf.insert(self.buf.get_end_iter(), "\n") 
        return True

    def printInstrument(self, track, mbtrack, rels):
        return True

class TrackInfoDispatcher(mpx.Plugin):

    def __init__(self):

        self.xml = gtk.glade.XML("@DATA_DIR@" + "/scripts/trackinfo/trackinfo.glade")
        self.notebook = self.xml.get_widget("notebook-track-info-1")

    def activate(self,player,mcs):
        self.player = player
        self.player_infoarea_click_id = self.player.gobj().connect("infoarea-click", self.new_track)
        self.info = TrackInfo(self.xml)
        self.player.add_info_widget(self.notebook, "Track Info")
        self.notebook.show_all()
        print ">> TrackInfo Plugin activated"
        return True

    def deactivate(self):
        self.player.gobj().disconnect(self.player_infoarea_click_id)
        self.player = None
        self.info = None
        print ">> TrackInfo Plugin deactivated"

    def new_track(self, blah):
        print blah
        m = self.player.get_metadata()
        self.info.run(m)


