// Copyright (C) 2005-2007 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include <xsd/cxx/pre.hxx>

#include "rss.hxx"

// tRss
// 

const tRss::channel_type& tRss::
channel () const
{
  return this->channel_.get ();
}

tRss::channel_type& tRss::
channel ()
{
  return this->channel_.get ();
}

void tRss::
channel (const channel_type& channel)
{
  this->channel_.set (channel);
}

void tRss::
channel (::std::auto_ptr< channel_type > channel)
{
  this->channel_.set (channel);
}

const tRss::version_type& tRss::
version () const
{
  return this->version_.get ();
}

tRss::version_type& tRss::
version ()
{
  return this->version_.get ();
}

void tRss::
version (const version_type& version)
{
  this->version_.set (version);
}

const tRss::version_type& tRss::
version_default_value ()
{
  return version_default_value_;
}


// tRssItem
// 

const tRssItem::title_sequence& tRssItem::
title () const
{
  return this->title_;
}

tRssItem::title_sequence& tRssItem::
title ()
{
  return this->title_;
}

void tRssItem::
title (const title_sequence& title)
{
  this->title_ = title;
}

const tRssItem::description_sequence& tRssItem::
description () const
{
  return this->description_;
}

tRssItem::description_sequence& tRssItem::
description ()
{
  return this->description_;
}

void tRssItem::
description (const description_sequence& description)
{
  this->description_ = description;
}

const tRssItem::link_sequence& tRssItem::
link () const
{
  return this->link_;
}

tRssItem::link_sequence& tRssItem::
link ()
{
  return this->link_;
}

void tRssItem::
link (const link_sequence& link)
{
  this->link_ = link;
}

const tRssItem::author_sequence& tRssItem::
author () const
{
  return this->author_;
}

tRssItem::author_sequence& tRssItem::
author ()
{
  return this->author_;
}

void tRssItem::
author (const author_sequence& author)
{
  this->author_ = author;
}

const tRssItem::category_sequence& tRssItem::
category () const
{
  return this->category_;
}

tRssItem::category_sequence& tRssItem::
category ()
{
  return this->category_;
}

void tRssItem::
category (const category_sequence& category)
{
  this->category_ = category;
}

const tRssItem::comments_sequence& tRssItem::
comments () const
{
  return this->comments_;
}

tRssItem::comments_sequence& tRssItem::
comments ()
{
  return this->comments_;
}

void tRssItem::
comments (const comments_sequence& comments)
{
  this->comments_ = comments;
}

const tRssItem::enclosure_sequence& tRssItem::
enclosure () const
{
  return this->enclosure_;
}

tRssItem::enclosure_sequence& tRssItem::
enclosure ()
{
  return this->enclosure_;
}

void tRssItem::
enclosure (const enclosure_sequence& enclosure)
{
  this->enclosure_ = enclosure;
}

const tRssItem::guid_sequence& tRssItem::
guid () const
{
  return this->guid_;
}

tRssItem::guid_sequence& tRssItem::
guid ()
{
  return this->guid_;
}

void tRssItem::
guid (const guid_sequence& guid)
{
  this->guid_ = guid;
}

const tRssItem::pubDate_sequence& tRssItem::
pubDate () const
{
  return this->pubDate_;
}

tRssItem::pubDate_sequence& tRssItem::
pubDate ()
{
  return this->pubDate_;
}

void tRssItem::
pubDate (const pubDate_sequence& pubDate)
{
  this->pubDate_ = pubDate;
}

const tRssItem::source_sequence& tRssItem::
source () const
{
  return this->source_;
}

tRssItem::source_sequence& tRssItem::
source ()
{
  return this->source_;
}

void tRssItem::
source (const source_sequence& source)
{
  this->source_ = source;
}


// tRssChannel
// 

const tRssChannel::title_sequence& tRssChannel::
title () const
{
  return this->title_;
}

tRssChannel::title_sequence& tRssChannel::
title ()
{
  return this->title_;
}

void tRssChannel::
title (const title_sequence& title)
{
  this->title_ = title;
}

const tRssChannel::link_sequence& tRssChannel::
link () const
{
  return this->link_;
}

tRssChannel::link_sequence& tRssChannel::
link ()
{
  return this->link_;
}

void tRssChannel::
link (const link_sequence& link)
{
  this->link_ = link;
}

const tRssChannel::description_sequence& tRssChannel::
description () const
{
  return this->description_;
}

tRssChannel::description_sequence& tRssChannel::
description ()
{
  return this->description_;
}

void tRssChannel::
description (const description_sequence& description)
{
  this->description_ = description;
}

const tRssChannel::language_sequence& tRssChannel::
language () const
{
  return this->language_;
}

tRssChannel::language_sequence& tRssChannel::
language ()
{
  return this->language_;
}

void tRssChannel::
language (const language_sequence& language)
{
  this->language_ = language;
}

const tRssChannel::copyright_sequence& tRssChannel::
copyright () const
{
  return this->copyright_;
}

tRssChannel::copyright_sequence& tRssChannel::
copyright ()
{
  return this->copyright_;
}

void tRssChannel::
copyright (const copyright_sequence& copyright)
{
  this->copyright_ = copyright;
}

const tRssChannel::managingEditor_sequence& tRssChannel::
managingEditor () const
{
  return this->managingEditor_;
}

tRssChannel::managingEditor_sequence& tRssChannel::
managingEditor ()
{
  return this->managingEditor_;
}

void tRssChannel::
managingEditor (const managingEditor_sequence& managingEditor)
{
  this->managingEditor_ = managingEditor;
}

const tRssChannel::webMaster_sequence& tRssChannel::
webMaster () const
{
  return this->webMaster_;
}

tRssChannel::webMaster_sequence& tRssChannel::
webMaster ()
{
  return this->webMaster_;
}

void tRssChannel::
webMaster (const webMaster_sequence& webMaster)
{
  this->webMaster_ = webMaster;
}

const tRssChannel::pubDate_sequence& tRssChannel::
pubDate () const
{
  return this->pubDate_;
}

tRssChannel::pubDate_sequence& tRssChannel::
pubDate ()
{
  return this->pubDate_;
}

void tRssChannel::
pubDate (const pubDate_sequence& pubDate)
{
  this->pubDate_ = pubDate;
}

const tRssChannel::lastBuildDate_sequence& tRssChannel::
lastBuildDate () const
{
  return this->lastBuildDate_;
}

tRssChannel::lastBuildDate_sequence& tRssChannel::
lastBuildDate ()
{
  return this->lastBuildDate_;
}

void tRssChannel::
lastBuildDate (const lastBuildDate_sequence& lastBuildDate)
{
  this->lastBuildDate_ = lastBuildDate;
}

const tRssChannel::category_sequence& tRssChannel::
category () const
{
  return this->category_;
}

tRssChannel::category_sequence& tRssChannel::
category ()
{
  return this->category_;
}

void tRssChannel::
category (const category_sequence& category)
{
  this->category_ = category;
}

const tRssChannel::generator_sequence& tRssChannel::
generator () const
{
  return this->generator_;
}

tRssChannel::generator_sequence& tRssChannel::
generator ()
{
  return this->generator_;
}

void tRssChannel::
generator (const generator_sequence& generator)
{
  this->generator_ = generator;
}

const tRssChannel::docs_sequence& tRssChannel::
docs () const
{
  return this->docs_;
}

tRssChannel::docs_sequence& tRssChannel::
docs ()
{
  return this->docs_;
}

void tRssChannel::
docs (const docs_sequence& docs)
{
  this->docs_ = docs;
}

const tRssChannel::cloud_sequence& tRssChannel::
cloud () const
{
  return this->cloud_;
}

tRssChannel::cloud_sequence& tRssChannel::
cloud ()
{
  return this->cloud_;
}

void tRssChannel::
cloud (const cloud_sequence& cloud)
{
  this->cloud_ = cloud;
}

const tRssChannel::ttl_sequence& tRssChannel::
ttl () const
{
  return this->ttl_;
}

tRssChannel::ttl_sequence& tRssChannel::
ttl ()
{
  return this->ttl_;
}

void tRssChannel::
ttl (const ttl_sequence& ttl)
{
  this->ttl_ = ttl;
}

const tRssChannel::image_sequence& tRssChannel::
image () const
{
  return this->image_;
}

tRssChannel::image_sequence& tRssChannel::
image ()
{
  return this->image_;
}

void tRssChannel::
image (const image_sequence& image)
{
  this->image_ = image;
}

const tRssChannel::textInput_sequence& tRssChannel::
textInput () const
{
  return this->textInput_;
}

tRssChannel::textInput_sequence& tRssChannel::
textInput ()
{
  return this->textInput_;
}

void tRssChannel::
textInput (const textInput_sequence& textInput)
{
  this->textInput_ = textInput;
}

const tRssChannel::skipHours_sequence& tRssChannel::
skipHours () const
{
  return this->skipHours_;
}

tRssChannel::skipHours_sequence& tRssChannel::
skipHours ()
{
  return this->skipHours_;
}

void tRssChannel::
skipHours (const skipHours_sequence& skipHours)
{
  this->skipHours_ = skipHours;
}

const tRssChannel::skipDays_sequence& tRssChannel::
skipDays () const
{
  return this->skipDays_;
}

tRssChannel::skipDays_sequence& tRssChannel::
skipDays ()
{
  return this->skipDays_;
}

void tRssChannel::
skipDays (const skipDays_sequence& skipDays)
{
  this->skipDays_ = skipDays;
}

const tRssChannel::item_sequence& tRssChannel::
item () const
{
  return this->item_;
}

tRssChannel::item_sequence& tRssChannel::
item ()
{
  return this->item_;
}

void tRssChannel::
item (const item_sequence& item)
{
  this->item_ = item;
}


// tSkipHour
// 


// tSkipHoursList
// 

const tSkipHoursList::hour_sequence& tSkipHoursList::
hour () const
{
  return this->hour_;
}

tSkipHoursList::hour_sequence& tSkipHoursList::
hour ()
{
  return this->hour_;
}

void tSkipHoursList::
hour (const hour_sequence& hour)
{
  this->hour_ = hour;
}


// tSkipDay
// 

tSkipDay::
tSkipDay (value v)
: ::xml_schema::string (_xsd_tSkipDay_literals_[v])
{
}

tSkipDay::
tSkipDay (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

tSkipDay::
tSkipDay (const tSkipDay& v,
          ::xml_schema::flags f,
          ::xml_schema::type* c)
: ::xml_schema::string (v, f, c)
{
}

tSkipDay& tSkipDay::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_tSkipDay_literals_[v]);

  return *this;
}


// tSkipDaysList
// 

const tSkipDaysList::day_sequence& tSkipDaysList::
day () const
{
  return this->day_;
}

tSkipDaysList::day_sequence& tSkipDaysList::
day ()
{
  return this->day_;
}

void tSkipDaysList::
day (const day_sequence& day)
{
  this->day_ = day;
}


// tCategory
// 

const tCategory::domain_optional& tCategory::
domain () const
{
  return this->domain_;
}

tCategory::domain_optional& tCategory::
domain ()
{
  return this->domain_;
}

void tCategory::
domain (const domain_type& domain)
{
  this->domain_.set (domain);
}

void tCategory::
domain (const domain_optional& domain)
{
  this->domain_ = domain;
}

void tCategory::
domain (::std::auto_ptr< domain_type > domain)
{
  this->domain_.set (domain);
}


// tImage
// 

const tImage::url_type& tImage::
url () const
{
  return this->url_.get ();
}

tImage::url_type& tImage::
url ()
{
  return this->url_.get ();
}

void tImage::
url (const url_type& url)
{
  this->url_.set (url);
}

void tImage::
url (::std::auto_ptr< url_type > url)
{
  this->url_.set (url);
}

const tImage::title_type& tImage::
title () const
{
  return this->title_.get ();
}

tImage::title_type& tImage::
title ()
{
  return this->title_.get ();
}

void tImage::
title (const title_type& title)
{
  this->title_.set (title);
}

void tImage::
title (::std::auto_ptr< title_type > title)
{
  this->title_.set (title);
}

const tImage::link_type& tImage::
link () const
{
  return this->link_.get ();
}

tImage::link_type& tImage::
link ()
{
  return this->link_.get ();
}

void tImage::
link (const link_type& link)
{
  this->link_.set (link);
}

void tImage::
link (::std::auto_ptr< link_type > link)
{
  this->link_.set (link);
}

const tImage::width_optional& tImage::
width () const
{
  return this->width_;
}

tImage::width_optional& tImage::
width ()
{
  return this->width_;
}

void tImage::
width (const width_type& width)
{
  this->width_.set (width);
}

void tImage::
width (const width_optional& width)
{
  this->width_ = width;
}

void tImage::
width (::std::auto_ptr< width_type > width)
{
  this->width_.set (width);
}

const tImage::width_type& tImage::
width_default_value ()
{
  return width_default_value_;
}

const tImage::height_optional& tImage::
height () const
{
  return this->height_;
}

tImage::height_optional& tImage::
height ()
{
  return this->height_;
}

void tImage::
height (const height_type& height)
{
  this->height_.set (height);
}

void tImage::
height (const height_optional& height)
{
  this->height_ = height;
}

void tImage::
height (::std::auto_ptr< height_type > height)
{
  this->height_.set (height);
}

const tImage::height_type& tImage::
height_default_value ()
{
  return height_default_value_;
}

const tImage::description_optional& tImage::
description () const
{
  return this->description_;
}

tImage::description_optional& tImage::
description ()
{
  return this->description_;
}

void tImage::
description (const description_type& description)
{
  this->description_.set (description);
}

void tImage::
description (const description_optional& description)
{
  this->description_ = description;
}

void tImage::
description (::std::auto_ptr< description_type > description)
{
  this->description_.set (description);
}


// tImageHeight
// 


// tImageWidth
// 


// tCloud
// 

const tCloud::domain_type& tCloud::
domain () const
{
  return this->domain_.get ();
}

tCloud::domain_type& tCloud::
domain ()
{
  return this->domain_.get ();
}

void tCloud::
domain (const domain_type& domain)
{
  this->domain_.set (domain);
}

void tCloud::
domain (::std::auto_ptr< domain_type > domain)
{
  this->domain_.set (domain);
}

const tCloud::port_type& tCloud::
port () const
{
  return this->port_.get ();
}

tCloud::port_type& tCloud::
port ()
{
  return this->port_.get ();
}

void tCloud::
port (const port_type& port)
{
  this->port_.set (port);
}

const tCloud::path_type& tCloud::
path () const
{
  return this->path_.get ();
}

tCloud::path_type& tCloud::
path ()
{
  return this->path_.get ();
}

void tCloud::
path (const path_type& path)
{
  this->path_.set (path);
}

void tCloud::
path (::std::auto_ptr< path_type > path)
{
  this->path_.set (path);
}

const tCloud::registerProcedure_type& tCloud::
registerProcedure () const
{
  return this->registerProcedure_.get ();
}

tCloud::registerProcedure_type& tCloud::
registerProcedure ()
{
  return this->registerProcedure_.get ();
}

void tCloud::
registerProcedure (const registerProcedure_type& registerProcedure)
{
  this->registerProcedure_.set (registerProcedure);
}

void tCloud::
registerProcedure (::std::auto_ptr< registerProcedure_type > registerProcedure)
{
  this->registerProcedure_.set (registerProcedure);
}

const tCloud::protocol_type& tCloud::
protocol () const
{
  return this->protocol_.get ();
}

tCloud::protocol_type& tCloud::
protocol ()
{
  return this->protocol_.get ();
}

void tCloud::
protocol (const protocol_type& protocol)
{
  this->protocol_.set (protocol);
}

void tCloud::
protocol (::std::auto_ptr< protocol_type > protocol)
{
  this->protocol_.set (protocol);
}


// tCloudProtocol
// 

tCloudProtocol::
tCloudProtocol (value v)
: ::xml_schema::string (_xsd_tCloudProtocol_literals_[v])
{
}

tCloudProtocol::
tCloudProtocol (const ::xml_schema::string& v)
: ::xml_schema::string (v)
{
}

tCloudProtocol::
tCloudProtocol (const tCloudProtocol& v,
                ::xml_schema::flags f,
                ::xml_schema::type* c)
: ::xml_schema::string (v, f, c)
{
}

tCloudProtocol& tCloudProtocol::
operator= (value v)
{
  static_cast< ::xml_schema::string& > (*this) = 
  ::xml_schema::string (_xsd_tCloudProtocol_literals_[v]);

  return *this;
}


// tTextInput
// 

const tTextInput::title_type& tTextInput::
title () const
{
  return this->title_.get ();
}

tTextInput::title_type& tTextInput::
title ()
{
  return this->title_.get ();
}

void tTextInput::
title (const title_type& title)
{
  this->title_.set (title);
}

void tTextInput::
title (::std::auto_ptr< title_type > title)
{
  this->title_.set (title);
}

const tTextInput::description_type& tTextInput::
description () const
{
  return this->description_.get ();
}

tTextInput::description_type& tTextInput::
description ()
{
  return this->description_.get ();
}

void tTextInput::
description (const description_type& description)
{
  this->description_.set (description);
}

void tTextInput::
description (::std::auto_ptr< description_type > description)
{
  this->description_.set (description);
}

const tTextInput::name_type& tTextInput::
name () const
{
  return this->name_.get ();
}

tTextInput::name_type& tTextInput::
name ()
{
  return this->name_.get ();
}

void tTextInput::
name (const name_type& name)
{
  this->name_.set (name);
}

void tTextInput::
name (::std::auto_ptr< name_type > name)
{
  this->name_.set (name);
}

const tTextInput::link_type& tTextInput::
link () const
{
  return this->link_.get ();
}

tTextInput::link_type& tTextInput::
link ()
{
  return this->link_.get ();
}

void tTextInput::
link (const link_type& link)
{
  this->link_.set (link);
}

void tTextInput::
link (::std::auto_ptr< link_type > link)
{
  this->link_.set (link);
}


// tEmailAddress
// 


// tRfc822FormatDate
// 


// tSource
// 

const tSource::url_optional& tSource::
url () const
{
  return this->url_;
}

tSource::url_optional& tSource::
url ()
{
  return this->url_;
}

void tSource::
url (const url_type& url)
{
  this->url_.set (url);
}

void tSource::
url (const url_optional& url)
{
  this->url_ = url;
}

void tSource::
url (::std::auto_ptr< url_type > url)
{
  this->url_.set (url);
}


// tEnclosure
// 

const tEnclosure::url_type& tEnclosure::
url () const
{
  return this->url_.get ();
}

tEnclosure::url_type& tEnclosure::
url ()
{
  return this->url_.get ();
}

void tEnclosure::
url (const url_type& url)
{
  this->url_.set (url);
}

void tEnclosure::
url (::std::auto_ptr< url_type > url)
{
  this->url_.set (url);
}

const tEnclosure::length_type& tEnclosure::
length () const
{
  return this->length_.get ();
}

tEnclosure::length_type& tEnclosure::
length ()
{
  return this->length_.get ();
}

void tEnclosure::
length (const length_type& length)
{
  this->length_.set (length);
}

const tEnclosure::type_type& tEnclosure::
type () const
{
  return this->type_.get ();
}

tEnclosure::type_type& tEnclosure::
type ()
{
  return this->type_.get ();
}

void tEnclosure::
type (const type_type& type)
{
  this->type_.set (type);
}

void tEnclosure::
type (::std::auto_ptr< type_type > type)
{
  this->type_.set (type);
}


// tGuid
// 

const tGuid::isPermaLink_type& tGuid::
isPermaLink () const
{
  return this->isPermaLink_.get ();
}

tGuid::isPermaLink_type& tGuid::
isPermaLink ()
{
  return this->isPermaLink_.get ();
}

void tGuid::
isPermaLink (const isPermaLink_type& isPermaLink)
{
  this->isPermaLink_.set (isPermaLink);
}

const tGuid::isPermaLink_type& tGuid::
isPermaLink_default_value ()
{
  return isPermaLink_default_value_;
}


#include <xsd/cxx/xml/dom/parsing-source.hxx>

// tRss
//

const tRss::version_type tRss::version_default_value_ (
  ::xsd::cxx::tree::traits< ::xml_schema::decimal, char >::create (
    ::std::string ("2.0"), 0, 0, 0));

tRss::
tRss (const channel_type& channel,
      const version_type& version)
: ::xml_schema::type (),
  channel_ (channel, ::xml_schema::flags (), this),
  version_ (version, ::xml_schema::flags (), this)
{
}

tRss::
tRss (const tRss& x,
      ::xml_schema::flags f,
      ::xml_schema::type* c)
: ::xml_schema::type (x, f, c),
  channel_ (x.channel_, f, this),
  version_ (x.version_, f, this)
{
}

tRss::
tRss (const ::xercesc::DOMElement& e,
      ::xml_schema::flags f,
      ::xml_schema::type* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  channel_ (f, this),
  version_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void tRss::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // channel
    //
    if (n.name () == "channel" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< channel_type > r (
        channel_traits::create (i, f, this));

      if (!channel_.present ())
      {
        this->channel (r);
        continue;
      }
    }

    break;
  }

  if (!channel_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "channel",
      "");
  }

  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "version" && n.namespace_ ().empty ())
    {
      this->version (version_traits::create (i, f, this));
      continue;
    }
  }

  if (!version_.present ())
  {
    this->version (
      version_traits::create (
        ::std::string ("2.0"),
        &p.element (), f, this));
  }
}

tRss* tRss::
_clone (::xml_schema::flags f,
        ::xml_schema::type* c) const
{
  return new tRss (*this, f, c);
}

// tRssItem
//

tRssItem::
tRssItem ()
: ::xml_schema::type (),
  title_ (::xml_schema::flags (), this),
  description_ (::xml_schema::flags (), this),
  link_ (::xml_schema::flags (), this),
  author_ (::xml_schema::flags (), this),
  category_ (::xml_schema::flags (), this),
  comments_ (::xml_schema::flags (), this),
  enclosure_ (::xml_schema::flags (), this),
  guid_ (::xml_schema::flags (), this),
  pubDate_ (::xml_schema::flags (), this),
  source_ (::xml_schema::flags (), this)
{
}

tRssItem::
tRssItem (const tRssItem& x,
          ::xml_schema::flags f,
          ::xml_schema::type* c)
: ::xml_schema::type (x, f, c),
  title_ (x.title_, f, this),
  description_ (x.description_, f, this),
  link_ (x.link_, f, this),
  author_ (x.author_, f, this),
  category_ (x.category_, f, this),
  comments_ (x.comments_, f, this),
  enclosure_ (x.enclosure_, f, this),
  guid_ (x.guid_, f, this),
  pubDate_ (x.pubDate_, f, this),
  source_ (x.source_, f, this)
{
}

tRssItem::
tRssItem (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::type* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  title_ (f, this),
  description_ (f, this),
  link_ (f, this),
  author_ (f, this),
  category_ (f, this),
  comments_ (f, this),
  enclosure_ (f, this),
  guid_ (f, this),
  pubDate_ (f, this),
  source_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void tRssItem::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // title
    //
    if (n.name () == "title" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< title_type > r (
        title_traits::create (i, f, this));

      this->title ().push_back (r);
      continue;
    }

    // description
    //
    if (n.name () == "description" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< description_type > r (
        description_traits::create (i, f, this));

      this->description ().push_back (r);
      continue;
    }

    // link
    //
    if (n.name () == "link" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< link_type > r (
        link_traits::create (i, f, this));

      this->link ().push_back (r);
      continue;
    }

    // author
    //
    if (n.name () == "author" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< author_type > r (
        author_traits::create (i, f, this));

      this->author ().push_back (r);
      continue;
    }

    // category
    //
    if (n.name () == "category" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< category_type > r (
        category_traits::create (i, f, this));

      this->category ().push_back (r);
      continue;
    }

    // comments
    //
    if (n.name () == "comments" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< comments_type > r (
        comments_traits::create (i, f, this));

      this->comments ().push_back (r);
      continue;
    }

    // enclosure
    //
    if (n.name () == "enclosure" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< enclosure_type > r (
        enclosure_traits::create (i, f, this));

      this->enclosure ().push_back (r);
      continue;
    }

    // guid
    //
    if (n.name () == "guid" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< guid_type > r (
        guid_traits::create (i, f, this));

      this->guid ().push_back (r);
      continue;
    }

    // pubDate
    //
    if (n.name () == "pubDate" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< pubDate_type > r (
        pubDate_traits::create (i, f, this));

      this->pubDate ().push_back (r);
      continue;
    }

    // source
    //
    if (n.name () == "source" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< source_type > r (
        source_traits::create (i, f, this));

      this->source ().push_back (r);
      continue;
    }

    break;
  }
}

tRssItem* tRssItem::
_clone (::xml_schema::flags f,
        ::xml_schema::type* c) const
{
  return new tRssItem (*this, f, c);
}

// tRssChannel
//

tRssChannel::
tRssChannel ()
: ::xml_schema::type (),
  title_ (::xml_schema::flags (), this),
  link_ (::xml_schema::flags (), this),
  description_ (::xml_schema::flags (), this),
  language_ (::xml_schema::flags (), this),
  copyright_ (::xml_schema::flags (), this),
  managingEditor_ (::xml_schema::flags (), this),
  webMaster_ (::xml_schema::flags (), this),
  pubDate_ (::xml_schema::flags (), this),
  lastBuildDate_ (::xml_schema::flags (), this),
  category_ (::xml_schema::flags (), this),
  generator_ (::xml_schema::flags (), this),
  docs_ (::xml_schema::flags (), this),
  cloud_ (::xml_schema::flags (), this),
  ttl_ (::xml_schema::flags (), this),
  image_ (::xml_schema::flags (), this),
  textInput_ (::xml_schema::flags (), this),
  skipHours_ (::xml_schema::flags (), this),
  skipDays_ (::xml_schema::flags (), this),
  item_ (::xml_schema::flags (), this)
{
}

tRssChannel::
tRssChannel (const tRssChannel& x,
             ::xml_schema::flags f,
             ::xml_schema::type* c)
: ::xml_schema::type (x, f, c),
  title_ (x.title_, f, this),
  link_ (x.link_, f, this),
  description_ (x.description_, f, this),
  language_ (x.language_, f, this),
  copyright_ (x.copyright_, f, this),
  managingEditor_ (x.managingEditor_, f, this),
  webMaster_ (x.webMaster_, f, this),
  pubDate_ (x.pubDate_, f, this),
  lastBuildDate_ (x.lastBuildDate_, f, this),
  category_ (x.category_, f, this),
  generator_ (x.generator_, f, this),
  docs_ (x.docs_, f, this),
  cloud_ (x.cloud_, f, this),
  ttl_ (x.ttl_, f, this),
  image_ (x.image_, f, this),
  textInput_ (x.textInput_, f, this),
  skipHours_ (x.skipHours_, f, this),
  skipDays_ (x.skipDays_, f, this),
  item_ (x.item_, f, this)
{
}

tRssChannel::
tRssChannel (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::type* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  title_ (f, this),
  link_ (f, this),
  description_ (f, this),
  language_ (f, this),
  copyright_ (f, this),
  managingEditor_ (f, this),
  webMaster_ (f, this),
  pubDate_ (f, this),
  lastBuildDate_ (f, this),
  category_ (f, this),
  generator_ (f, this),
  docs_ (f, this),
  cloud_ (f, this),
  ttl_ (f, this),
  image_ (f, this),
  textInput_ (f, this),
  skipHours_ (f, this),
  skipDays_ (f, this),
  item_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void tRssChannel::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // title
    //
    if (n.name () == "title" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< title_type > r (
        title_traits::create (i, f, this));

      this->title ().push_back (r);
      continue;
    }

    // link
    //
    if (n.name () == "link" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< link_type > r (
        link_traits::create (i, f, this));

      this->link ().push_back (r);
      continue;
    }

    // description
    //
    if (n.name () == "description" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< description_type > r (
        description_traits::create (i, f, this));

      this->description ().push_back (r);
      continue;
    }

    // language
    //
    if (n.name () == "language" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< language_type > r (
        language_traits::create (i, f, this));

      this->language ().push_back (r);
      continue;
    }

    // copyright
    //
    if (n.name () == "copyright" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< copyright_type > r (
        copyright_traits::create (i, f, this));

      this->copyright ().push_back (r);
      continue;
    }

    // managingEditor
    //
    if (n.name () == "managingEditor" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< managingEditor_type > r (
        managingEditor_traits::create (i, f, this));

      this->managingEditor ().push_back (r);
      continue;
    }

    // webMaster
    //
    if (n.name () == "webMaster" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< webMaster_type > r (
        webMaster_traits::create (i, f, this));

      this->webMaster ().push_back (r);
      continue;
    }

    // pubDate
    //
    if (n.name () == "pubDate" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< pubDate_type > r (
        pubDate_traits::create (i, f, this));

      this->pubDate ().push_back (r);
      continue;
    }

    // lastBuildDate
    //
    if (n.name () == "lastBuildDate" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< lastBuildDate_type > r (
        lastBuildDate_traits::create (i, f, this));

      this->lastBuildDate ().push_back (r);
      continue;
    }

    // category
    //
    if (n.name () == "category" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< category_type > r (
        category_traits::create (i, f, this));

      this->category ().push_back (r);
      continue;
    }

    // generator
    //
    if (n.name () == "generator" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< generator_type > r (
        generator_traits::create (i, f, this));

      this->generator ().push_back (r);
      continue;
    }

    // docs
    //
    if (n.name () == "docs" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< docs_type > r (
        docs_traits::create (i, f, this));

      this->docs ().push_back (r);
      continue;
    }

    // cloud
    //
    if (n.name () == "cloud" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< cloud_type > r (
        cloud_traits::create (i, f, this));

      this->cloud ().push_back (r);
      continue;
    }

    // ttl
    //
    if (n.name () == "ttl" && n.namespace_ ().empty ())
    {
      this->ttl ().push_back (ttl_traits::create (i, f, this));
      continue;
    }

    // image
    //
    if (n.name () == "image" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< image_type > r (
        image_traits::create (i, f, this));

      this->image ().push_back (r);
      continue;
    }

    // textInput
    //
    if (n.name () == "textInput" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< textInput_type > r (
        textInput_traits::create (i, f, this));

      this->textInput ().push_back (r);
      continue;
    }

    // skipHours
    //
    if (n.name () == "skipHours" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< skipHours_type > r (
        skipHours_traits::create (i, f, this));

      this->skipHours ().push_back (r);
      continue;
    }

    // skipDays
    //
    if (n.name () == "skipDays" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< skipDays_type > r (
        skipDays_traits::create (i, f, this));

      this->skipDays ().push_back (r);
      continue;
    }

    // item
    //
    if (n.name () == "item" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< item_type > r (
        item_traits::create (i, f, this));

      this->item ().push_back (r);
      continue;
    }

    break;
  }
}

tRssChannel* tRssChannel::
_clone (::xml_schema::flags f,
        ::xml_schema::type* c) const
{
  return new tRssChannel (*this, f, c);
}

// tSkipHour
//

tSkipHour::
tSkipHour (const ::xml_schema::non_negative_integer& nonNegativeInteger)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::non_negative_integer, char, ::xml_schema::simple_type > (nonNegativeInteger)
{
}

tSkipHour::
tSkipHour (const tSkipHour& x,
           ::xml_schema::flags f,
           ::xml_schema::type* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::non_negative_integer, char, ::xml_schema::simple_type > (x, f, c)
{
}

tSkipHour::
tSkipHour (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::type* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::non_negative_integer, char, ::xml_schema::simple_type > (e, f, c)
{
}

tSkipHour::
tSkipHour (const ::xercesc::DOMAttr& a,
           ::xml_schema::flags f,
           ::xml_schema::type* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::non_negative_integer, char, ::xml_schema::simple_type > (a, f, c)
{
}

tSkipHour::
tSkipHour (const ::std::string& s,
           const ::xercesc::DOMElement* e,
           ::xml_schema::flags f,
           ::xml_schema::type* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::non_negative_integer, char, ::xml_schema::simple_type > (s, e, f, c)
{
}

tSkipHour* tSkipHour::
_clone (::xml_schema::flags f,
        ::xml_schema::type* c) const
{
  return new tSkipHour (*this, f, c);
}

// tSkipHoursList
//

tSkipHoursList::
tSkipHoursList ()
: ::xml_schema::type (),
  hour_ (::xml_schema::flags (), this)
{
}

tSkipHoursList::
tSkipHoursList (const tSkipHoursList& x,
                ::xml_schema::flags f,
                ::xml_schema::type* c)
: ::xml_schema::type (x, f, c),
  hour_ (x.hour_, f, this)
{
}

tSkipHoursList::
tSkipHoursList (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::type* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  hour_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void tSkipHoursList::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // hour
    //
    if (n.name () == "hour" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< hour_type > r (
        hour_traits::create (i, f, this));

      this->hour ().push_back (r);
      continue;
    }

    break;
  }
}

tSkipHoursList* tSkipHoursList::
_clone (::xml_schema::flags f,
        ::xml_schema::type* c) const
{
  return new tSkipHoursList (*this, f, c);
}

// tSkipDay
//

tSkipDay::
tSkipDay (const ::xercesc::DOMElement& e,
          ::xml_schema::flags f,
          ::xml_schema::type* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_tSkipDay_convert ();
}

tSkipDay::
tSkipDay (const ::xercesc::DOMAttr& a,
          ::xml_schema::flags f,
          ::xml_schema::type* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_tSkipDay_convert ();
}

tSkipDay::
tSkipDay (const ::std::string& s,
          const ::xercesc::DOMElement* e,
          ::xml_schema::flags f,
          ::xml_schema::type* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_tSkipDay_convert ();
}

tSkipDay* tSkipDay::
_clone (::xml_schema::flags f,
        ::xml_schema::type* c) const
{
  return new tSkipDay (*this, f, c);
}

tSkipDay::value tSkipDay::
_xsd_tSkipDay_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_tSkipDay_literals_);
  const value* i (::std::lower_bound (
                    _xsd_tSkipDay_indexes_,
                    _xsd_tSkipDay_indexes_ + 7,
                    *this,
                    c));

  if (i == _xsd_tSkipDay_indexes_ + 7 || _xsd_tSkipDay_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const tSkipDay::
_xsd_tSkipDay_literals_[7] =
{
  "Monday",
  "Tuesday",
  "Wednesday",
  "Thursday",
  "Friday",
  "Saturday",
  "Sunday"
};

const tSkipDay::value tSkipDay::
_xsd_tSkipDay_indexes_[7] =
{
  ::tSkipDay::Friday,
  ::tSkipDay::Monday,
  ::tSkipDay::Saturday,
  ::tSkipDay::Sunday,
  ::tSkipDay::Thursday,
  ::tSkipDay::Tuesday,
  ::tSkipDay::Wednesday
};

// tSkipDaysList
//

tSkipDaysList::
tSkipDaysList ()
: ::xml_schema::type (),
  day_ (::xml_schema::flags (), this)
{
}

tSkipDaysList::
tSkipDaysList (const tSkipDaysList& x,
               ::xml_schema::flags f,
               ::xml_schema::type* c)
: ::xml_schema::type (x, f, c),
  day_ (x.day_, f, this)
{
}

tSkipDaysList::
tSkipDaysList (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::type* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  day_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void tSkipDaysList::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // day
    //
    if (n.name () == "day" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< day_type > r (
        day_traits::create (i, f, this));

      this->day ().push_back (r);
      continue;
    }

    break;
  }
}

tSkipDaysList* tSkipDaysList::
_clone (::xml_schema::flags f,
        ::xml_schema::type* c) const
{
  return new tSkipDaysList (*this, f, c);
}

// tCategory
//

tCategory::
tCategory ()
: ::xml_schema::string (),
  domain_ (::xml_schema::flags (), this)
{
}

tCategory::
tCategory (const ::xml_schema::string& string)
: ::xml_schema::string (string),
  domain_ (::xml_schema::flags (), this)
{
}

tCategory::
tCategory (const tCategory& x,
           ::xml_schema::flags f,
           ::xml_schema::type* c)
: ::xml_schema::string (x, f, c),
  domain_ (x.domain_, f, this)
{
}

tCategory::
tCategory (const ::xercesc::DOMElement& e,
           ::xml_schema::flags f,
           ::xml_schema::type* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  domain_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void tCategory::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "domain" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< domain_type > r (
        domain_traits::create (i, f, this));

      this->domain (r);
      continue;
    }
  }
}

tCategory* tCategory::
_clone (::xml_schema::flags f,
        ::xml_schema::type* c) const
{
  return new tCategory (*this, f, c);
}

// tImage
//

const tImage::width_type tImage::width_default_value_ (
  ::std::string ("88"), 0, 0, 0);

const tImage::height_type tImage::height_default_value_ (
  ::std::string ("31"), 0, 0, 0);

tImage::
tImage (const url_type& url,
        const title_type& title,
        const link_type& link)
: ::xml_schema::type (),
  url_ (url, ::xml_schema::flags (), this),
  title_ (title, ::xml_schema::flags (), this),
  link_ (link, ::xml_schema::flags (), this),
  width_ (::xml_schema::flags (), this),
  height_ (::xml_schema::flags (), this),
  description_ (::xml_schema::flags (), this)
{
}

tImage::
tImage (const tImage& x,
        ::xml_schema::flags f,
        ::xml_schema::type* c)
: ::xml_schema::type (x, f, c),
  url_ (x.url_, f, this),
  title_ (x.title_, f, this),
  link_ (x.link_, f, this),
  width_ (x.width_, f, this),
  height_ (x.height_, f, this),
  description_ (x.description_, f, this)
{
}

tImage::
tImage (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::type* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  url_ (f, this),
  title_ (f, this),
  link_ (f, this),
  width_ (f, this),
  height_ (f, this),
  description_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void tImage::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // url
    //
    if (n.name () == "url" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< url_type > r (
        url_traits::create (i, f, this));

      if (!url_.present ())
      {
        this->url (r);
        continue;
      }
    }

    // title
    //
    if (n.name () == "title" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< title_type > r (
        title_traits::create (i, f, this));

      if (!title_.present ())
      {
        this->title (r);
        continue;
      }
    }

    // link
    //
    if (n.name () == "link" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< link_type > r (
        link_traits::create (i, f, this));

      if (!link_.present ())
      {
        this->link (r);
        continue;
      }
    }

    // width
    //
    if (n.name () == "width" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< width_type > r (
        width_traits::create (i, f, this));

      if (!this->width ())
      {
        this->width (r);
        continue;
      }
    }

    // height
    //
    if (n.name () == "height" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< height_type > r (
        height_traits::create (i, f, this));

      if (!this->height ())
      {
        this->height (r);
        continue;
      }
    }

    // description
    //
    if (n.name () == "description" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< description_type > r (
        description_traits::create (i, f, this));

      if (!this->description ())
      {
        this->description (r);
        continue;
      }
    }

    break;
  }

  if (!url_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "url",
      "");
  }

  if (!title_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "title",
      "");
  }

  if (!link_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "link",
      "");
  }
}

tImage* tImage::
_clone (::xml_schema::flags f,
        ::xml_schema::type* c) const
{
  return new tImage (*this, f, c);
}

// tImageHeight
//

tImageHeight::
tImageHeight (const ::xml_schema::positive_integer& positiveInteger)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::positive_integer, char, ::xml_schema::simple_type > (positiveInteger)
{
}

tImageHeight::
tImageHeight (const tImageHeight& x,
              ::xml_schema::flags f,
              ::xml_schema::type* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::positive_integer, char, ::xml_schema::simple_type > (x, f, c)
{
}

tImageHeight::
tImageHeight (const ::xercesc::DOMElement& e,
              ::xml_schema::flags f,
              ::xml_schema::type* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::positive_integer, char, ::xml_schema::simple_type > (e, f, c)
{
}

tImageHeight::
tImageHeight (const ::xercesc::DOMAttr& a,
              ::xml_schema::flags f,
              ::xml_schema::type* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::positive_integer, char, ::xml_schema::simple_type > (a, f, c)
{
}

tImageHeight::
tImageHeight (const ::std::string& s,
              const ::xercesc::DOMElement* e,
              ::xml_schema::flags f,
              ::xml_schema::type* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::positive_integer, char, ::xml_schema::simple_type > (s, e, f, c)
{
}

tImageHeight* tImageHeight::
_clone (::xml_schema::flags f,
        ::xml_schema::type* c) const
{
  return new tImageHeight (*this, f, c);
}

// tImageWidth
//

tImageWidth::
tImageWidth (const ::xml_schema::positive_integer& positiveInteger)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::positive_integer, char, ::xml_schema::simple_type > (positiveInteger)
{
}

tImageWidth::
tImageWidth (const tImageWidth& x,
             ::xml_schema::flags f,
             ::xml_schema::type* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::positive_integer, char, ::xml_schema::simple_type > (x, f, c)
{
}

tImageWidth::
tImageWidth (const ::xercesc::DOMElement& e,
             ::xml_schema::flags f,
             ::xml_schema::type* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::positive_integer, char, ::xml_schema::simple_type > (e, f, c)
{
}

tImageWidth::
tImageWidth (const ::xercesc::DOMAttr& a,
             ::xml_schema::flags f,
             ::xml_schema::type* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::positive_integer, char, ::xml_schema::simple_type > (a, f, c)
{
}

tImageWidth::
tImageWidth (const ::std::string& s,
             const ::xercesc::DOMElement* e,
             ::xml_schema::flags f,
             ::xml_schema::type* c)
: ::xsd::cxx::tree::fundamental_base< ::xml_schema::positive_integer, char, ::xml_schema::simple_type > (s, e, f, c)
{
}

tImageWidth* tImageWidth::
_clone (::xml_schema::flags f,
        ::xml_schema::type* c) const
{
  return new tImageWidth (*this, f, c);
}

// tCloud
//

tCloud::
tCloud (const domain_type& domain,
        const port_type& port,
        const path_type& path,
        const registerProcedure_type& registerProcedure,
        const protocol_type& protocol)
: ::xml_schema::type (),
  domain_ (domain, ::xml_schema::flags (), this),
  port_ (port, ::xml_schema::flags (), this),
  path_ (path, ::xml_schema::flags (), this),
  registerProcedure_ (registerProcedure, ::xml_schema::flags (), this),
  protocol_ (protocol, ::xml_schema::flags (), this)
{
}

tCloud::
tCloud (const tCloud& x,
        ::xml_schema::flags f,
        ::xml_schema::type* c)
: ::xml_schema::type (x, f, c),
  domain_ (x.domain_, f, this),
  port_ (x.port_, f, this),
  path_ (x.path_, f, this),
  registerProcedure_ (x.registerProcedure_, f, this),
  protocol_ (x.protocol_, f, this)
{
}

tCloud::
tCloud (const ::xercesc::DOMElement& e,
        ::xml_schema::flags f,
        ::xml_schema::type* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  domain_ (f, this),
  port_ (f, this),
  path_ (f, this),
  registerProcedure_ (f, this),
  protocol_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void tCloud::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "domain" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< domain_type > r (
        domain_traits::create (i, f, this));

      this->domain (r);
      continue;
    }

    if (n.name () == "port" && n.namespace_ ().empty ())
    {
      this->port (port_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "path" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< path_type > r (
        path_traits::create (i, f, this));

      this->path (r);
      continue;
    }

    if (n.name () == "registerProcedure" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< registerProcedure_type > r (
        registerProcedure_traits::create (i, f, this));

      this->registerProcedure (r);
      continue;
    }

    if (n.name () == "protocol" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< protocol_type > r (
        protocol_traits::create (i, f, this));

      this->protocol (r);
      continue;
    }
  }

  if (!domain_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "domain",
      "");
  }

  if (!port_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "port",
      "");
  }

  if (!path_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "path",
      "");
  }

  if (!registerProcedure_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "registerProcedure",
      "");
  }

  if (!protocol_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "protocol",
      "");
  }
}

tCloud* tCloud::
_clone (::xml_schema::flags f,
        ::xml_schema::type* c) const
{
  return new tCloud (*this, f, c);
}

// tCloudProtocol
//

tCloudProtocol::
tCloudProtocol (const ::xercesc::DOMElement& e,
                ::xml_schema::flags f,
                ::xml_schema::type* c)
: ::xml_schema::string (e, f, c)
{
  _xsd_tCloudProtocol_convert ();
}

tCloudProtocol::
tCloudProtocol (const ::xercesc::DOMAttr& a,
                ::xml_schema::flags f,
                ::xml_schema::type* c)
: ::xml_schema::string (a, f, c)
{
  _xsd_tCloudProtocol_convert ();
}

tCloudProtocol::
tCloudProtocol (const ::std::string& s,
                const ::xercesc::DOMElement* e,
                ::xml_schema::flags f,
                ::xml_schema::type* c)
: ::xml_schema::string (s, e, f, c)
{
  _xsd_tCloudProtocol_convert ();
}

tCloudProtocol* tCloudProtocol::
_clone (::xml_schema::flags f,
        ::xml_schema::type* c) const
{
  return new tCloudProtocol (*this, f, c);
}

tCloudProtocol::value tCloudProtocol::
_xsd_tCloudProtocol_convert () const
{
  ::xsd::cxx::tree::enum_comparator< char > c (_xsd_tCloudProtocol_literals_);
  const value* i (::std::lower_bound (
                    _xsd_tCloudProtocol_indexes_,
                    _xsd_tCloudProtocol_indexes_ + 3,
                    *this,
                    c));

  if (i == _xsd_tCloudProtocol_indexes_ + 3 || _xsd_tCloudProtocol_literals_[*i] != *this)
  {
    throw ::xsd::cxx::tree::unexpected_enumerator < char > (*this);
  }

  return *i;
}

const char* const tCloudProtocol::
_xsd_tCloudProtocol_literals_[3] =
{
  "xml-rpc",
  "http-post",
  "soap"
};

const tCloudProtocol::value tCloudProtocol::
_xsd_tCloudProtocol_indexes_[3] =
{
  ::tCloudProtocol::http_post,
  ::tCloudProtocol::soap,
  ::tCloudProtocol::xml_rpc
};

// tTextInput
//

tTextInput::
tTextInput (const title_type& title,
            const description_type& description,
            const name_type& name,
            const link_type& link)
: ::xml_schema::type (),
  title_ (title, ::xml_schema::flags (), this),
  description_ (description, ::xml_schema::flags (), this),
  name_ (name, ::xml_schema::flags (), this),
  link_ (link, ::xml_schema::flags (), this)
{
}

tTextInput::
tTextInput (const tTextInput& x,
            ::xml_schema::flags f,
            ::xml_schema::type* c)
: ::xml_schema::type (x, f, c),
  title_ (x.title_, f, this),
  description_ (x.description_, f, this),
  name_ (x.name_, f, this),
  link_ (x.link_, f, this)
{
}

tTextInput::
tTextInput (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::type* c)
: ::xml_schema::type (e, f | ::xml_schema::flags::base, c),
  title_ (f, this),
  description_ (f, this),
  name_ (f, this),
  link_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void tTextInput::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  for (; p.more_elements (); p.next_element ())
  {
    const ::xercesc::DOMElement& i (p.cur_element ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    // title
    //
    if (n.name () == "title" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< title_type > r (
        title_traits::create (i, f, this));

      if (!title_.present ())
      {
        this->title (r);
        continue;
      }
    }

    // description
    //
    if (n.name () == "description" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< description_type > r (
        description_traits::create (i, f, this));

      if (!description_.present ())
      {
        this->description (r);
        continue;
      }
    }

    // name
    //
    if (n.name () == "name" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< name_type > r (
        name_traits::create (i, f, this));

      if (!name_.present ())
      {
        this->name (r);
        continue;
      }
    }

    // link
    //
    if (n.name () == "link" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< link_type > r (
        link_traits::create (i, f, this));

      if (!link_.present ())
      {
        this->link (r);
        continue;
      }
    }

    break;
  }

  if (!title_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "title",
      "");
  }

  if (!description_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "description",
      "");
  }

  if (!name_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "name",
      "");
  }

  if (!link_.present ())
  {
    throw ::xsd::cxx::tree::expected_element< char > (
      "link",
      "");
  }
}

tTextInput* tTextInput::
_clone (::xml_schema::flags f,
        ::xml_schema::type* c) const
{
  return new tTextInput (*this, f, c);
}

// tEmailAddress
//

tEmailAddress::
tEmailAddress ()
: ::xml_schema::string ()
{
}

tEmailAddress::
tEmailAddress (const ::xml_schema::string& string)
: ::xml_schema::string (string)
{
}

tEmailAddress::
tEmailAddress (const tEmailAddress& x,
               ::xml_schema::flags f,
               ::xml_schema::type* c)
: ::xml_schema::string (x, f, c)
{
}

tEmailAddress::
tEmailAddress (const ::xercesc::DOMElement& e,
               ::xml_schema::flags f,
               ::xml_schema::type* c)
: ::xml_schema::string (e, f, c)
{
}

tEmailAddress::
tEmailAddress (const ::xercesc::DOMAttr& a,
               ::xml_schema::flags f,
               ::xml_schema::type* c)
: ::xml_schema::string (a, f, c)
{
}

tEmailAddress::
tEmailAddress (const ::std::string& s,
               const ::xercesc::DOMElement* e,
               ::xml_schema::flags f,
               ::xml_schema::type* c)
: ::xml_schema::string (s, e, f, c)
{
}

tEmailAddress* tEmailAddress::
_clone (::xml_schema::flags f,
        ::xml_schema::type* c) const
{
  return new tEmailAddress (*this, f, c);
}

// tRfc822FormatDate
//

tRfc822FormatDate::
tRfc822FormatDate ()
: ::xml_schema::string ()
{
}

tRfc822FormatDate::
tRfc822FormatDate (const ::xml_schema::string& string)
: ::xml_schema::string (string)
{
}

tRfc822FormatDate::
tRfc822FormatDate (const tRfc822FormatDate& x,
                   ::xml_schema::flags f,
                   ::xml_schema::type* c)
: ::xml_schema::string (x, f, c)
{
}

tRfc822FormatDate::
tRfc822FormatDate (const ::xercesc::DOMElement& e,
                   ::xml_schema::flags f,
                   ::xml_schema::type* c)
: ::xml_schema::string (e, f, c)
{
}

tRfc822FormatDate::
tRfc822FormatDate (const ::xercesc::DOMAttr& a,
                   ::xml_schema::flags f,
                   ::xml_schema::type* c)
: ::xml_schema::string (a, f, c)
{
}

tRfc822FormatDate::
tRfc822FormatDate (const ::std::string& s,
                   const ::xercesc::DOMElement* e,
                   ::xml_schema::flags f,
                   ::xml_schema::type* c)
: ::xml_schema::string (s, e, f, c)
{
}

tRfc822FormatDate* tRfc822FormatDate::
_clone (::xml_schema::flags f,
        ::xml_schema::type* c) const
{
  return new tRfc822FormatDate (*this, f, c);
}

// tSource
//

tSource::
tSource ()
: ::xml_schema::string (),
  url_ (::xml_schema::flags (), this)
{
}

tSource::
tSource (const ::xml_schema::string& string)
: ::xml_schema::string (string),
  url_ (::xml_schema::flags (), this)
{
}

tSource::
tSource (const tSource& x,
         ::xml_schema::flags f,
         ::xml_schema::type* c)
: ::xml_schema::string (x, f, c),
  url_ (x.url_, f, this)
{
}

tSource::
tSource (const ::xercesc::DOMElement& e,
         ::xml_schema::flags f,
         ::xml_schema::type* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  url_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void tSource::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "url" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< url_type > r (
        url_traits::create (i, f, this));

      this->url (r);
      continue;
    }
  }
}

tSource* tSource::
_clone (::xml_schema::flags f,
        ::xml_schema::type* c) const
{
  return new tSource (*this, f, c);
}

// tEnclosure
//

tEnclosure::
tEnclosure (const url_type& url,
            const length_type& length,
            const type_type& type)
: ::xml_schema::string (),
  url_ (url, ::xml_schema::flags (), this),
  length_ (length, ::xml_schema::flags (), this),
  type_ (type, ::xml_schema::flags (), this)
{
}

tEnclosure::
tEnclosure (const ::xml_schema::string& string,
            const url_type& url,
            const length_type& length,
            const type_type& type)
: ::xml_schema::string (string),
  url_ (url, ::xml_schema::flags (), this),
  length_ (length, ::xml_schema::flags (), this),
  type_ (type, ::xml_schema::flags (), this)
{
}

tEnclosure::
tEnclosure (const tEnclosure& x,
            ::xml_schema::flags f,
            ::xml_schema::type* c)
: ::xml_schema::string (x, f, c),
  url_ (x.url_, f, this),
  length_ (x.length_, f, this),
  type_ (x.type_, f, this)
{
}

tEnclosure::
tEnclosure (const ::xercesc::DOMElement& e,
            ::xml_schema::flags f,
            ::xml_schema::type* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  url_ (f, this),
  length_ (f, this),
  type_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void tEnclosure::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "url" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< url_type > r (
        url_traits::create (i, f, this));

      this->url (r);
      continue;
    }

    if (n.name () == "length" && n.namespace_ ().empty ())
    {
      this->length (length_traits::create (i, f, this));
      continue;
    }

    if (n.name () == "type" && n.namespace_ ().empty ())
    {
      ::std::auto_ptr< type_type > r (
        type_traits::create (i, f, this));

      this->type (r);
      continue;
    }
  }

  if (!url_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "url",
      "");
  }

  if (!length_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "length",
      "");
  }

  if (!type_.present ())
  {
    throw ::xsd::cxx::tree::expected_attribute< char > (
      "type",
      "");
  }
}

tEnclosure* tEnclosure::
_clone (::xml_schema::flags f,
        ::xml_schema::type* c) const
{
  return new tEnclosure (*this, f, c);
}

// tGuid
//

const tGuid::isPermaLink_type tGuid::isPermaLink_default_value_ (
  ::xsd::cxx::tree::traits< ::xml_schema::boolean, char >::create (
    ::std::string ("true"), 0, 0, 0));

tGuid::
tGuid ()
: ::xml_schema::string (),
  isPermaLink_ (isPermaLink_default_value (), ::xml_schema::flags (), this)
{
}

tGuid::
tGuid (const ::xml_schema::string& string)
: ::xml_schema::string (string),
  isPermaLink_ (isPermaLink_default_value (), ::xml_schema::flags (), this)
{
}

tGuid::
tGuid (const tGuid& x,
       ::xml_schema::flags f,
       ::xml_schema::type* c)
: ::xml_schema::string (x, f, c),
  isPermaLink_ (x.isPermaLink_, f, this)
{
}

tGuid::
tGuid (const ::xercesc::DOMElement& e,
       ::xml_schema::flags f,
       ::xml_schema::type* c)
: ::xml_schema::string (e, f | ::xml_schema::flags::base, c),
  isPermaLink_ (f, this)
{
  if ((f & ::xml_schema::flags::base) == 0)
  {
    ::xsd::cxx::xml::dom::parser< char > p (e);
    this->parse (p, f);
  }
}

void tGuid::
parse (::xsd::cxx::xml::dom::parser< char >& p,
       ::xml_schema::flags f)
{
  while (p.more_attributes ())
  {
    const ::xercesc::DOMAttr& i (p.next_attribute ());
    const ::xsd::cxx::xml::qualified_name< char > n (
      ::xsd::cxx::xml::dom::name< char > (i));

    if (n.name () == "isPermaLink" && n.namespace_ ().empty ())
    {
      this->isPermaLink (isPermaLink_traits::create (i, f, this));
      continue;
    }
  }

  if (!isPermaLink_.present ())
  {
    this->isPermaLink (
      isPermaLink_traits::create (
        ::std::string ("true"),
        &p.element (), f, this));
  }
}

tGuid* tGuid::
_clone (::xml_schema::flags f,
        ::xml_schema::type* c) const
{
  return new tGuid (*this, f, c);
}

#include <istream>
#include <xercesc/framework/Wrapper4InputSource.hpp>
#include <xsd/cxx/xml/sax/std-input-source.hxx>
#include <xsd/cxx/tree/error-handler.hxx>

::std::auto_ptr< ::tRss >
rss (const ::std::string& u,
     ::xml_schema::flags f,
     const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::tree::error_handler< char > h;

  ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  ::std::auto_ptr< ::tRss > r (
    ::rss (
      d.get (), f | ::xml_schema::flags::own_dom, p));

  if (f & ::xml_schema::flags::keep_dom)
    d.release ();

  return r;
}

::std::auto_ptr< ::tRss >
rss (const ::std::string& u,
     ::xml_schema::error_handler& h,
     ::xml_schema::flags f,
     const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

  if (!d)
    throw ::xsd::cxx::tree::parsing< char > ();

  ::std::auto_ptr< ::tRss > r (
    ::rss (
      d.get (), f | ::xml_schema::flags::own_dom, p));

  if (f & ::xml_schema::flags::keep_dom)
    d.release ();

  return r;
}

::std::auto_ptr< ::tRss >
rss (const ::std::string& u,
     ::xercesc::DOMErrorHandler& h,
     ::xml_schema::flags f,
     const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (u, h, p, f));

  if (!d)
    throw ::xsd::cxx::tree::parsing< char > ();

  ::std::auto_ptr< ::tRss > r (
    ::rss (
      d.get (), f | ::xml_schema::flags::own_dom, p));

  if (f & ::xml_schema::flags::keep_dom)
    d.release ();

  return r;
}

::std::auto_ptr< ::tRss >
rss (::std::istream& is,
     ::xml_schema::flags f,
     const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  ::xercesc::Wrapper4InputSource wrap (&isrc, false);
  return ::rss (wrap, f, p);
}

::std::auto_ptr< ::tRss >
rss (::std::istream& is,
     ::xml_schema::error_handler& h,
     ::xml_schema::flags f,
     const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  ::xercesc::Wrapper4InputSource wrap (&isrc, false);
  return ::rss (wrap, h, f, p);
}

::std::auto_ptr< ::tRss >
rss (::std::istream& is,
     ::xercesc::DOMErrorHandler& h,
     ::xml_schema::flags f,
     const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is);
  ::xercesc::Wrapper4InputSource wrap (&isrc, false);
  return ::rss (wrap, h, f, p);
}

::std::auto_ptr< ::tRss >
rss (::std::istream& is,
     const ::std::string& sid,
     ::xml_schema::flags f,
     const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  ::xercesc::Wrapper4InputSource wrap (&isrc, false);
  return ::rss (wrap, f, p);
}

::std::auto_ptr< ::tRss >
rss (::std::istream& is,
     const ::std::string& sid,
     ::xml_schema::error_handler& h,
     ::xml_schema::flags f,
     const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::auto_initializer i (
    (f & ::xml_schema::flags::dont_initialize) == 0,
    (f & ::xml_schema::flags::keep_dom) == 0);

  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  ::xercesc::Wrapper4InputSource wrap (&isrc, false);
  return ::rss (wrap, h, f, p);
}

::std::auto_ptr< ::tRss >
rss (::std::istream& is,
     const ::std::string& sid,
     ::xercesc::DOMErrorHandler& h,
     ::xml_schema::flags f,
     const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::sax::std_input_source isrc (is, sid);
  ::xercesc::Wrapper4InputSource wrap (&isrc, false);
  return ::rss (wrap, h, f, p);
}

::std::auto_ptr< ::tRss >
rss (const ::xercesc::DOMInputSource& i,
     ::xml_schema::flags f,
     const ::xml_schema::properties& p)
{
  ::xsd::cxx::tree::error_handler< char > h;

  ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

  h.throw_if_failed< ::xsd::cxx::tree::parsing< char > > ();

  ::std::auto_ptr< ::tRss > r (
    ::rss (
      d.get (), f | ::xml_schema::flags::own_dom, p));

  if (f & ::xml_schema::flags::keep_dom)
    d.release ();

  return r;
}

::std::auto_ptr< ::tRss >
rss (const ::xercesc::DOMInputSource& i,
     ::xml_schema::error_handler& h,
     ::xml_schema::flags f,
     const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

  if (!d)
    throw ::xsd::cxx::tree::parsing< char > ();

  ::std::auto_ptr< ::tRss > r (
    ::rss (
      d.get (), f | ::xml_schema::flags::own_dom, p));

  if (f & ::xml_schema::flags::keep_dom)
    d.release ();

  return r;
}

::std::auto_ptr< ::tRss >
rss (const ::xercesc::DOMInputSource& i,
     ::xercesc::DOMErrorHandler& h,
     ::xml_schema::flags f,
     const ::xml_schema::properties& p)
{
  ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > d (
    ::xsd::cxx::xml::dom::parse< char > (i, h, p, f));

  if (!d)
    throw ::xsd::cxx::tree::parsing< char > ();

  ::std::auto_ptr< ::tRss > r (
    ::rss (
      d.get (), f | ::xml_schema::flags::own_dom, p));

  if (f & ::xml_schema::flags::keep_dom)
    d.release ();

  return r;
}

::std::auto_ptr< ::tRss >
rss (const ::xercesc::DOMDocument& d,
     ::xml_schema::flags f,
     const ::xml_schema::properties& p)
{
  if (f & ::xml_schema::flags::keep_dom)
  {
    ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
      static_cast< ::xercesc::DOMDocument* > (d.cloneNode (true)));

    ::std::auto_ptr< ::tRss > r (
      ::rss (
        c.get (), f | ::xml_schema::flags::own_dom, p));

    c.release ();
    return r;
  }

  const ::xercesc::DOMElement& e (*d.getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (n.name () == "rss" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::tRss > r (
      ::xsd::cxx::tree::traits< ::tRss, char >::create (
        e, f, 0));
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "rss",
    "");
}

::std::auto_ptr< ::tRss >
rss (::xercesc::DOMDocument* d,
     ::xml_schema::flags f,
     const ::xml_schema::properties&)
{
  ::xsd::cxx::xml::dom::auto_ptr< ::xercesc::DOMDocument > c (
    ((f & ::xml_schema::flags::keep_dom) &&
     !(f & ::xml_schema::flags::own_dom))
    ? static_cast< ::xercesc::DOMDocument* > (d->cloneNode (true))
    : 0);

  const ::xercesc::DOMElement& e (
    c.get ()
    ? *c->getDocumentElement ()
    : *d->getDocumentElement ());
  const ::xsd::cxx::xml::qualified_name< char > n (
    ::xsd::cxx::xml::dom::name< char > (e));

  if (n.name () == "rss" &&
      n.namespace_ () == "")
  {
    ::std::auto_ptr< ::tRss > r (
      ::xsd::cxx::tree::traits< ::tRss, char >::create (
        e, f, 0));
    c.release ();
    return r;
  }

  throw ::xsd::cxx::tree::unexpected_element < char > (
    n.name (),
    n.namespace_ (),
    "rss",
    "");
}

#include <xsd/cxx/post.hxx>

// Begin epilogue.
//
//
// End epilogue.

